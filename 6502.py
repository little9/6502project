#!/usr/bin/env python
# -*- coding: utf-8 -*- 

#
# Generated Tue Dec 11 19:48:32 2012 by generateDS.py version 2.7c.
#

import sys
import getopt
import re as re_

etree_ = None
Verbose_import_ = False
(   XMLParser_import_none, XMLParser_import_lxml,
    XMLParser_import_elementtree
    ) = range(3)
XMLParser_import_library = None
try:
    # lxml
    from lxml import etree as etree_
    XMLParser_import_library = XMLParser_import_lxml
    if Verbose_import_:
        print("running with lxml.etree")
except ImportError:
    try:
        # cElementTree from Python 2.5+
        import xml.etree.cElementTree as etree_
        XMLParser_import_library = XMLParser_import_elementtree
        if Verbose_import_:
            print("running with cElementTree on Python 2.5+")
    except ImportError:
        try:
            # ElementTree from Python 2.5+
            import xml.etree.ElementTree as etree_
            XMLParser_import_library = XMLParser_import_elementtree
            if Verbose_import_:
                print("running with ElementTree on Python 2.5+")
        except ImportError:
            try:
                # normal cElementTree install
                import cElementTree as etree_
                XMLParser_import_library = XMLParser_import_elementtree
                if Verbose_import_:
                    print("running with cElementTree")
            except ImportError:
                try:
                    # normal ElementTree install
                    import elementtree.ElementTree as etree_
                    XMLParser_import_library = XMLParser_import_elementtree
                    if Verbose_import_:
                        print("running with ElementTree")
                except ImportError:
                    raise ImportError("Failed to import ElementTree from any known place")

def parsexml_(*args, **kwargs):
    if (XMLParser_import_library == XMLParser_import_lxml and
        'parser' not in kwargs):
        # Use the lxml ElementTree compatible parser so that, e.g.,
        #   we ignore comments.
        kwargs['parser'] = etree_.ETCompatXMLParser()
    doc = etree_.parse(*args, **kwargs)
    return doc

#
# User methods
#
# Calls to the methods in these classes are generated by generateDS.py.
# You can replace these methods by re-implementing the following class
#   in a module named generatedssuper.py.

try:
    from generatedssuper import GeneratedsSuper
except ImportError, exp:

    class GeneratedsSuper(object):
        def gds_format_string(self, input_data, input_name=''):
            return input_data
        def gds_validate_string(self, input_data, node, input_name=''):
            return input_data
        def gds_format_integer(self, input_data, input_name=''):
            return '%d' % input_data
        def gds_validate_integer(self, input_data, node, input_name=''):
            return input_data
        def gds_format_integer_list(self, input_data, input_name=''):
            return '%s' % input_data
        def gds_validate_integer_list(self, input_data, node, input_name=''):
            values = input_data.split()
            for value in values:
                try:
                    fvalue = float(value)
                except (TypeError, ValueError), exp:
                    raise_parse_error(node, 'Requires sequence of integers')
            return input_data
        def gds_format_float(self, input_data, input_name=''):
            return '%f' % input_data
        def gds_validate_float(self, input_data, node, input_name=''):
            return input_data
        def gds_format_float_list(self, input_data, input_name=''):
            return '%s' % input_data
        def gds_validate_float_list(self, input_data, node, input_name=''):
            values = input_data.split()
            for value in values:
                try:
                    fvalue = float(value)
                except (TypeError, ValueError), exp:
                    raise_parse_error(node, 'Requires sequence of floats')
            return input_data
        def gds_format_double(self, input_data, input_name=''):
            return '%e' % input_data
        def gds_validate_double(self, input_data, node, input_name=''):
            return input_data
        def gds_format_double_list(self, input_data, input_name=''):
            return '%s' % input_data
        def gds_validate_double_list(self, input_data, node, input_name=''):
            values = input_data.split()
            for value in values:
                try:
                    fvalue = float(value)
                except (TypeError, ValueError), exp:
                    raise_parse_error(node, 'Requires sequence of doubles')
            return input_data
        def gds_format_boolean(self, input_data, input_name=''):
            return '%s' % input_data
        def gds_validate_boolean(self, input_data, node, input_name=''):
            return input_data
        def gds_format_boolean_list(self, input_data, input_name=''):
            return '%s' % input_data
        def gds_validate_boolean_list(self, input_data, node, input_name=''):
            values = input_data.split()
            for value in values:
                if value not in ('true', '1', 'false', '0', ):
                    raise_parse_error(node, 'Requires sequence of booleans ("true", "1", "false", "0")')
            return input_data
        def gds_str_lower(self, instring):
            return instring.lower()
        def get_path_(self, node):
            path_list = []
            self.get_path_list_(node, path_list)
            path_list.reverse()
            path = '/'.join(path_list)
            return path
        Tag_strip_pattern_ = re_.compile(r'\{.*\}')
        def get_path_list_(self, node, path_list):
            if node is None:
                return
            tag = GeneratedsSuper.Tag_strip_pattern_.sub('', node.tag)
            if tag:
                path_list.append(tag)
            self.get_path_list_(node.getparent(), path_list)
        def get_class_obj_(self, node, default_class=None):
            class_obj1 = default_class
            if 'xsi' in node.nsmap:
                classname = node.get('{%s}type' % node.nsmap['xsi'])
                if classname is not None:
                    names = classname.split(':')
                    if len(names) == 2:
                        classname = names[1]
                    class_obj2 = globals().get(classname)
                    if class_obj2 is not None:
                        class_obj1 = class_obj2
            return class_obj1
        def gds_build_any(self, node, type_name=None):
            return None


#
# If you have installed IPython you can uncomment and use the following.
# IPython is available from http://ipython.scipy.org/.
#

## from IPython.Shell import IPShellEmbed
## args = ''
## ipshell = IPShellEmbed(args,
##     banner = 'Dropping into IPython',
##     exit_msg = 'Leaving Interpreter, back to program.')

# Then use the following line where and when you want to drop into the
# IPython shell:
#    ipshell('<some message> -- Entering ipshell.\nHit Ctrl-D to exit')

#
# Globals
#

ExternalEncoding = 'ascii'
Tag_pattern_ = re_.compile(r'({.*})?(.*)')
String_cleanup_pat_ = re_.compile(r"[\n\r\s]+")
Namespace_extract_pat_ = re_.compile(r'{(.*)}(.*)')

#
# Support/utility functions.
#

def showIndent(outfile, level, pretty_print=True):
    if pretty_print:
        for idx in range(level):
            outfile.write('    ')

def quote_xml(inStr):
    if not inStr:
        return ''
    s1 = (isinstance(inStr, basestring) and inStr or
          '%s' % inStr)
    s1 = s1.replace('&', '&amp;')
    s1 = s1.replace('<', '&lt;')
    s1 = s1.replace('>', '&gt;')
    return s1

def quote_attrib(inStr):
    s1 = (isinstance(inStr, basestring) and inStr or
          '%s' % inStr)
    s1 = s1.replace('&', '&amp;')
    s1 = s1.replace('<', '&lt;')
    s1 = s1.replace('>', '&gt;')
    if '"' in s1:
        if "'" in s1:
            s1 = '"%s"' % s1.replace('"', "&quot;")
        else:
            s1 = "'%s'" % s1
    else:
        s1 = '"%s"' % s1
    return s1

def quote_python(inStr):
    s1 = inStr
    if s1.find("'") == -1:
        if s1.find('\n') == -1:
            return "'%s'" % s1
        else:
            return "'''%s'''" % s1
    else:
        if s1.find('"') != -1:
            s1 = s1.replace('"', '\\"')
        if s1.find('\n') == -1:
            return '"%s"' % s1
        else:
            return '"""%s"""' % s1

def get_all_text_(node):
    if node.text is not None:
        text = node.text
    else:
        text = ''
    for child in node:
        if child.tail is not None:
            text += child.tail
    return text

def find_attr_value_(attr_name, node):
    attrs = node.attrib
    attr_parts = attr_name.split(':')
    value = None
    if len(attr_parts) == 1:
        value = attrs.get(attr_name)
    elif len(attr_parts) == 2:
        prefix, name = attr_parts
        namespace = node.nsmap.get(prefix)
        if namespace is not None:
            value = attrs.get('{%s}%s' % (namespace, name, ))
    return value


class GDSParseError(Exception):
    pass

def raise_parse_error(node, msg):
    if XMLParser_import_library == XMLParser_import_lxml:
        msg = '%s (element %s/line %d)' % (msg, node.tag, node.sourceline, )
    else:
        msg = '%s (element %s)' % (msg, node.tag, )
    raise GDSParseError(msg)


class MixedContainer:
    # Constants for category:
    CategoryNone = 0
    CategoryText = 1
    CategorySimple = 2
    CategoryComplex = 3
    # Constants for content_type:
    TypeNone = 0
    TypeText = 1
    TypeString = 2
    TypeInteger = 3
    TypeFloat = 4
    TypeDecimal = 5
    TypeDouble = 6
    TypeBoolean = 7
    def __init__(self, category, content_type, name, value):
        self.category = category
        self.content_type = content_type
        self.name = name
        self.value = value
    def getCategory(self):
        return self.category
    def getContenttype(self, content_type):
        return self.content_type
    def getValue(self):
        return self.value
    def getName(self):
        return self.name
    def export(self, outfile, level, name, namespace, pretty_print=True):
        if self.category == MixedContainer.CategoryText:
            # Prevent exporting empty content as empty lines.
            if self.value.strip(): 
                outfile.write(self.value)
        elif self.category == MixedContainer.CategorySimple:
            self.exportSimple(outfile, level, name)
        else:    # category == MixedContainer.CategoryComplex
            self.value.export(outfile, level, namespace, name, pretty_print)
    def exportSimple(self, outfile, level, name):
        if self.content_type == MixedContainer.TypeString:
            outfile.write('<%s>%s</%s>' % (self.name, self.value, self.name))
        elif self.content_type == MixedContainer.TypeInteger or \
                self.content_type == MixedContainer.TypeBoolean:
            outfile.write('<%s>%d</%s>' % (self.name, self.value, self.name))
        elif self.content_type == MixedContainer.TypeFloat or \
                self.content_type == MixedContainer.TypeDecimal:
            outfile.write('<%s>%f</%s>' % (self.name, self.value, self.name))
        elif self.content_type == MixedContainer.TypeDouble:
            outfile.write('<%s>%g</%s>' % (self.name, self.value, self.name))
    def exportLiteral(self, outfile, level, name):
        if self.category == MixedContainer.CategoryText:
            showIndent(outfile, level)
            outfile.write('model_.MixedContainer(%d, %d, "%s", "%s"),\n' % \
                (self.category, self.content_type, self.name, self.value))
        elif self.category == MixedContainer.CategorySimple:
            showIndent(outfile, level)
            outfile.write('model_.MixedContainer(%d, %d, "%s", "%s"),\n' % \
                (self.category, self.content_type, self.name, self.value))
        else:    # category == MixedContainer.CategoryComplex
            showIndent(outfile, level)
            outfile.write('model_.MixedContainer(%d, %d, "%s",\n' % \
                (self.category, self.content_type, self.name,))
            self.value.exportLiteral(outfile, level + 1)
            showIndent(outfile, level)
            outfile.write(')\n')


class MemberSpec_(object):
    def __init__(self, name='', data_type='', container=0):
        self.name = name
        self.data_type = data_type
        self.container = container
    def set_name(self, name): self.name = name
    def get_name(self): return self.name
    def set_data_type(self, data_type): self.data_type = data_type
    def get_data_type_chain(self): return self.data_type
    def get_data_type(self):
        if isinstance(self.data_type, list):
            if len(self.data_type) > 0:
                return self.data_type[-1]
            else:
                return 'xs:string'
        else:
            return self.data_type
    def set_container(self, container): self.container = container
    def get_container(self): return self.container

def _cast(typ, value):
    if typ is None or value is None:
        return value
    return typ(value)

#
# Data representation classes.
#

class sixfivezerotwo(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, annotation=None, lineGroup=None):
        if annotation is None:
            self.annotation = []
        else:
            self.annotation = annotation
        self.lineGroup = lineGroup
    def factory(*args_, **kwargs_):
        if sixfivezerotwo.subclass:
            return sixfivezerotwo.subclass(*args_, **kwargs_)
        else:
            return sixfivezerotwo(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_annotation(self): return self.annotation
    def set_annotation(self, annotation): self.annotation = annotation
    def add_annotation(self, value): self.annotation.append(value)
    def insert_annotation(self, index, value): self.annotation[index] = value
    def get_lineGroup(self): return self.lineGroup
    def set_lineGroup(self, lineGroup): self.lineGroup = lineGroup
    def export(self, outfile, level, namespace_='', name_='sixfivezerotwo', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = []
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='sixfivezerotwo')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_, name_, pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='sixfivezerotwo'):
        pass
    def exportChildren(self, outfile, level, namespace_='', name_='sixfivezerotwo', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        for annotation_ in self.annotation:
            annotation_.export(outfile, level, namespace_, name_='annotation', pretty_print=pretty_print)
        if self.lineGroup is not None:
            self.lineGroup.export(outfile, level, namespace_, name_='lineGroup', pretty_print=pretty_print)
    def hasContent_(self):
        if (
            self.annotation or
            self.lineGroup is not None
            ):
            return True
        else:
            return False
    def exportLiteral(self, outfile, level, name_='sixfivezerotwo'):
        level += 1
        self.exportLiteralAttributes(outfile, level, [], name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        pass
    def exportLiteralChildren(self, outfile, level, name_):
        showIndent(outfile, level)
        outfile.write('annotation=[\n')
        level += 1
        for annotation_ in self.annotation:
            showIndent(outfile, level)
            outfile.write('model_.annotation(\n')
            annotation_.exportLiteral(outfile, level)
            showIndent(outfile, level)
            outfile.write('),\n')
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
        if self.lineGroup is not None:
            showIndent(outfile, level)
            outfile.write('lineGroup=model_.lineGroup(\n')
            self.lineGroup.exportLiteral(outfile, level)
            showIndent(outfile, level)
            outfile.write('),\n')
    def build(self, node):
        self.buildAttributes(node, node.attrib, [])
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'annotation':
            obj_ = annotation.factory()
            obj_.build(child_)
            self.annotation.append(obj_)
        elif nodeName_ == 'lineGroup':
            obj_ = lineGroup.factory()
            obj_.build(child_)
            self.set_lineGroup(obj_)
# end class sixfivezerotwo


class label(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, name=None, lineGroup=None):
        self.name = name
        self.lineGroup = lineGroup
    def factory(*args_, **kwargs_):
        if label.subclass:
            return label.subclass(*args_, **kwargs_)
        else:
            return label(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_name(self): return self.name
    def set_name(self, name): self.name = name
    def get_lineGroup(self): return self.lineGroup
    def set_lineGroup(self, lineGroup): self.lineGroup = lineGroup
    def export(self, outfile, level, namespace_='', name_='label', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = []
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='label')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_, name_, pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='label'):
        pass
    def exportChildren(self, outfile, level, namespace_='', name_='label', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.name is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sname>%s</%sname>%s' % (namespace_, self.gds_format_string(quote_xml(self.name).encode(ExternalEncoding), input_name='name'), namespace_, eol_))
        if self.lineGroup is not None:
            self.lineGroup.export(outfile, level, namespace_, name_='lineGroup', pretty_print=pretty_print)
    def hasContent_(self):
        if (
            self.name is not None or
            self.lineGroup is not None
            ):
            return True
        else:
            return False
    def exportLiteral(self, outfile, level, name_='label'):
        level += 1
        self.exportLiteralAttributes(outfile, level, [], name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        pass
    def exportLiteralChildren(self, outfile, level, name_):
        if self.name is not None:
            showIndent(outfile, level)
            outfile.write('name=%s,\n' % quote_python(self.name).encode(ExternalEncoding))
        if self.lineGroup is not None:
            showIndent(outfile, level)
            outfile.write('lineGroup=model_.lineGroup(\n')
            self.lineGroup.exportLiteral(outfile, level)
            showIndent(outfile, level)
            outfile.write('),\n')
    def build(self, node):
        self.buildAttributes(node, node.attrib, [])
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'name':
            name_ = child_.text
            name_ = self.gds_validate_string(name_, node, 'name')
            self.name = name_
        elif nodeName_ == 'lineGroup':
            obj_ = lineGroup.factory()
            obj_.build(child_)
            self.set_lineGroup(obj_)
# end class label


class mnemonic(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, ADCaddWithCarry=None, ANDbitwiseAndWithAccumulator=None, ASLartihmeticShiftLeft=None, BITtestBits=None, BPLsetCarry=None, BMIbranchonMinus=None, BVCbranchonOverflowClear=None, BVSbranchonOverflowSet=None, BCCbranchonCarryClear=None, BCSbranchonCarrySet=None, BEQbranchonEqual=None, BNEbranchonNotequal=None, BRKbreak=None, CMPcompareAccumulator=None, CPXcompareXRegister=None, CPYcompareYRegister=None, DECdecrementMemory=None, EORbitWiseExclusiveOr=None, CLClearCarry=None, SECsetCarry=None, SEIsetCarry=None, CLIclearInterrupt=None, SEIsetInterrupt=None, CLVclearOverflow=None, CLDclearDecimal=None, SEDsetDecimal=None, INCincrementMemory=None, JMPjump=None, JSRjumpToSubRoutine=None, LDAloadAccumulator=None, LDXloadXRegister=None, LDYloadYRegister=None, LSRlogicalShiftRight=None, NOPnoOperation=None, ORAbitwiseOrWithAccumulator=None, TAXTtansferAtoX=None, TXAtransferXtoA=None, DEXdecrementX=None, INXincrementX=None, TAYtransferAtoY=None, DEYdecrementY=None, INYincrementY=None, ROLrotateLeft=None, RORrotateRight=None, RTIreturnFromInterrupt=None, RTSreturnFromSubroutine=None, SBCSubTractwithCarry=None, STAStoreAccumulator=None, TSXTransferXtoStackptr=None, TSXTranferStackPtrtoX=None, PHAPushAccumulator=None, PLApullAccumulator=None, PHPpushProcessorStatus=None, PLPpullProcessorsStatus=None, STXstoreXReigster=None, STYstoreYRegister=None):
        self.ADCaddWithCarry = ADCaddWithCarry
        self.ANDbitwiseAndWithAccumulator = ANDbitwiseAndWithAccumulator
        self.ASLartihmeticShiftLeft = ASLartihmeticShiftLeft
        self.BITtestBits = BITtestBits
        self.BPLsetCarry = BPLsetCarry
        self.BMIbranchonMinus = BMIbranchonMinus
        self.BVCbranchonOverflowClear = BVCbranchonOverflowClear
        self.BVSbranchonOverflowSet = BVSbranchonOverflowSet
        self.BCCbranchonCarryClear = BCCbranchonCarryClear
        self.BCSbranchonCarrySet = BCSbranchonCarrySet
        self.BEQbranchonEqual = BEQbranchonEqual
        self.BNEbranchonNotequal = BNEbranchonNotequal
        self.BRKbreak = BRKbreak
        self.CMPcompareAccumulator = CMPcompareAccumulator
        self.CPXcompareXRegister = CPXcompareXRegister
        self.CPYcompareYRegister = CPYcompareYRegister
        self.DECdecrementMemory = DECdecrementMemory
        self.EORbitWiseExclusiveOr = EORbitWiseExclusiveOr
        self.CLClearCarry = CLClearCarry
        self.SECsetCarry = SECsetCarry
        self.SEIsetCarry = SEIsetCarry
        self.CLIclearInterrupt = CLIclearInterrupt
        self.SEIsetInterrupt = SEIsetInterrupt
        self.CLVclearOverflow = CLVclearOverflow
        self.CLDclearDecimal = CLDclearDecimal
        self.SEDsetDecimal = SEDsetDecimal
        self.INCincrementMemory = INCincrementMemory
        self.JMPjump = JMPjump
        self.JSRjumpToSubRoutine = JSRjumpToSubRoutine
        self.LDAloadAccumulator = LDAloadAccumulator
        self.LDXloadXRegister = LDXloadXRegister
        self.LDYloadYRegister = LDYloadYRegister
        self.LSRlogicalShiftRight = LSRlogicalShiftRight
        self.NOPnoOperation = NOPnoOperation
        self.ORAbitwiseOrWithAccumulator = ORAbitwiseOrWithAccumulator
        self.TAXTtansferAtoX = TAXTtansferAtoX
        self.TXAtransferXtoA = TXAtransferXtoA
        self.DEXdecrementX = DEXdecrementX
        self.INXincrementX = INXincrementX
        self.TAYtransferAtoY = TAYtransferAtoY
        self.DEYdecrementY = DEYdecrementY
        self.INYincrementY = INYincrementY
        self.ROLrotateLeft = ROLrotateLeft
        self.RORrotateRight = RORrotateRight
        self.RTIreturnFromInterrupt = RTIreturnFromInterrupt
        self.RTSreturnFromSubroutine = RTSreturnFromSubroutine
        self.SBCSubTractwithCarry = SBCSubTractwithCarry
        self.STAStoreAccumulator = STAStoreAccumulator
        self.TSXTransferXtoStackptr = TSXTransferXtoStackptr
        self.TSXTranferStackPtrtoX = TSXTranferStackPtrtoX
        self.PHAPushAccumulator = PHAPushAccumulator
        self.PLApullAccumulator = PLApullAccumulator
        self.PHPpushProcessorStatus = PHPpushProcessorStatus
        self.PLPpullProcessorsStatus = PLPpullProcessorsStatus
        self.STXstoreXReigster = STXstoreXReigster
        self.STYstoreYRegister = STYstoreYRegister
    def factory(*args_, **kwargs_):
        if mnemonic.subclass:
            return mnemonic.subclass(*args_, **kwargs_)
        else:
            return mnemonic(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ADCaddWithCarry(self): return self.ADCaddWithCarry
    def set_ADCaddWithCarry(self, ADCaddWithCarry): self.ADCaddWithCarry = ADCaddWithCarry
    def get_ANDbitwiseAndWithAccumulator(self): return self.ANDbitwiseAndWithAccumulator
    def set_ANDbitwiseAndWithAccumulator(self, ANDbitwiseAndWithAccumulator): self.ANDbitwiseAndWithAccumulator = ANDbitwiseAndWithAccumulator
    def get_ASLartihmeticShiftLeft(self): return self.ASLartihmeticShiftLeft
    def set_ASLartihmeticShiftLeft(self, ASLartihmeticShiftLeft): self.ASLartihmeticShiftLeft = ASLartihmeticShiftLeft
    def get_BITtestBits(self): return self.BITtestBits
    def set_BITtestBits(self, BITtestBits): self.BITtestBits = BITtestBits
    def get_BPLsetCarry(self): return self.BPLsetCarry
    def set_BPLsetCarry(self, BPLsetCarry): self.BPLsetCarry = BPLsetCarry
    def get_BMIbranchonMinus(self): return self.BMIbranchonMinus
    def set_BMIbranchonMinus(self, BMIbranchonMinus): self.BMIbranchonMinus = BMIbranchonMinus
    def get_BVCbranchonOverflowClear(self): return self.BVCbranchonOverflowClear
    def set_BVCbranchonOverflowClear(self, BVCbranchonOverflowClear): self.BVCbranchonOverflowClear = BVCbranchonOverflowClear
    def get_BVSbranchonOverflowSet(self): return self.BVSbranchonOverflowSet
    def set_BVSbranchonOverflowSet(self, BVSbranchonOverflowSet): self.BVSbranchonOverflowSet = BVSbranchonOverflowSet
    def get_BCCbranchonCarryClear(self): return self.BCCbranchonCarryClear
    def set_BCCbranchonCarryClear(self, BCCbranchonCarryClear): self.BCCbranchonCarryClear = BCCbranchonCarryClear
    def get_BCSbranchonCarrySet(self): return self.BCSbranchonCarrySet
    def set_BCSbranchonCarrySet(self, BCSbranchonCarrySet): self.BCSbranchonCarrySet = BCSbranchonCarrySet
    def get_BEQbranchonEqual(self): return self.BEQbranchonEqual
    def set_BEQbranchonEqual(self, BEQbranchonEqual): self.BEQbranchonEqual = BEQbranchonEqual
    def get_BNEbranchonNotequal(self): return self.BNEbranchonNotequal
    def set_BNEbranchonNotequal(self, BNEbranchonNotequal): self.BNEbranchonNotequal = BNEbranchonNotequal
    def get_BRKbreak(self): return self.BRKbreak
    def set_BRKbreak(self, BRKbreak): self.BRKbreak = BRKbreak
    def get_CMPcompareAccumulator(self): return self.CMPcompareAccumulator
    def set_CMPcompareAccumulator(self, CMPcompareAccumulator): self.CMPcompareAccumulator = CMPcompareAccumulator
    def get_CPXcompareXRegister(self): return self.CPXcompareXRegister
    def set_CPXcompareXRegister(self, CPXcompareXRegister): self.CPXcompareXRegister = CPXcompareXRegister
    def get_CPYcompareYRegister(self): return self.CPYcompareYRegister
    def set_CPYcompareYRegister(self, CPYcompareYRegister): self.CPYcompareYRegister = CPYcompareYRegister
    def get_DECdecrementMemory(self): return self.DECdecrementMemory
    def set_DECdecrementMemory(self, DECdecrementMemory): self.DECdecrementMemory = DECdecrementMemory
    def get_EORbitWiseExclusiveOr(self): return self.EORbitWiseExclusiveOr
    def set_EORbitWiseExclusiveOr(self, EORbitWiseExclusiveOr): self.EORbitWiseExclusiveOr = EORbitWiseExclusiveOr
    def get_CLClearCarry(self): return self.CLClearCarry
    def set_CLClearCarry(self, CLClearCarry): self.CLClearCarry = CLClearCarry
    def get_SECsetCarry(self): return self.SECsetCarry
    def set_SECsetCarry(self, SECsetCarry): self.SECsetCarry = SECsetCarry
    def get_SEIsetCarry(self): return self.SEIsetCarry
    def set_SEIsetCarry(self, SEIsetCarry): self.SEIsetCarry = SEIsetCarry
    def get_CLIclearInterrupt(self): return self.CLIclearInterrupt
    def set_CLIclearInterrupt(self, CLIclearInterrupt): self.CLIclearInterrupt = CLIclearInterrupt
    def get_SEIsetInterrupt(self): return self.SEIsetInterrupt
    def set_SEIsetInterrupt(self, SEIsetInterrupt): self.SEIsetInterrupt = SEIsetInterrupt
    def get_CLVclearOverflow(self): return self.CLVclearOverflow
    def set_CLVclearOverflow(self, CLVclearOverflow): self.CLVclearOverflow = CLVclearOverflow
    def get_CLDclearDecimal(self): return self.CLDclearDecimal
    def set_CLDclearDecimal(self, CLDclearDecimal): self.CLDclearDecimal = CLDclearDecimal
    def get_SEDsetDecimal(self): return self.SEDsetDecimal
    def set_SEDsetDecimal(self, SEDsetDecimal): self.SEDsetDecimal = SEDsetDecimal
    def get_INCincrementMemory(self): return self.INCincrementMemory
    def set_INCincrementMemory(self, INCincrementMemory): self.INCincrementMemory = INCincrementMemory
    def get_JMPjump(self): return self.JMPjump
    def set_JMPjump(self, JMPjump): self.JMPjump = JMPjump
    def get_JSRjumpToSubRoutine(self): return self.JSRjumpToSubRoutine
    def set_JSRjumpToSubRoutine(self, JSRjumpToSubRoutine): self.JSRjumpToSubRoutine = JSRjumpToSubRoutine
    def get_LDAloadAccumulator(self): return self.LDAloadAccumulator
    def set_LDAloadAccumulator(self, LDAloadAccumulator): self.LDAloadAccumulator = LDAloadAccumulator
    def get_LDXloadXRegister(self): return self.LDXloadXRegister
    def set_LDXloadXRegister(self, LDXloadXRegister): self.LDXloadXRegister = LDXloadXRegister
    def get_LDYloadYRegister(self): return self.LDYloadYRegister
    def set_LDYloadYRegister(self, LDYloadYRegister): self.LDYloadYRegister = LDYloadYRegister
    def get_LSRlogicalShiftRight(self): return self.LSRlogicalShiftRight
    def set_LSRlogicalShiftRight(self, LSRlogicalShiftRight): self.LSRlogicalShiftRight = LSRlogicalShiftRight
    def get_NOPnoOperation(self): return self.NOPnoOperation
    def set_NOPnoOperation(self, NOPnoOperation): self.NOPnoOperation = NOPnoOperation
    def get_ORAbitwiseOrWithAccumulator(self): return self.ORAbitwiseOrWithAccumulator
    def set_ORAbitwiseOrWithAccumulator(self, ORAbitwiseOrWithAccumulator): self.ORAbitwiseOrWithAccumulator = ORAbitwiseOrWithAccumulator
    def get_TAXTtansferAtoX(self): return self.TAXTtansferAtoX
    def set_TAXTtansferAtoX(self, TAXTtansferAtoX): self.TAXTtansferAtoX = TAXTtansferAtoX
    def get_TXAtransferXtoA(self): return self.TXAtransferXtoA
    def set_TXAtransferXtoA(self, TXAtransferXtoA): self.TXAtransferXtoA = TXAtransferXtoA
    def get_DEXdecrementX(self): return self.DEXdecrementX
    def set_DEXdecrementX(self, DEXdecrementX): self.DEXdecrementX = DEXdecrementX
    def get_INXincrementX(self): return self.INXincrementX
    def set_INXincrementX(self, INXincrementX): self.INXincrementX = INXincrementX
    def get_TAYtransferAtoY(self): return self.TAYtransferAtoY
    def set_TAYtransferAtoY(self, TAYtransferAtoY): self.TAYtransferAtoY = TAYtransferAtoY
    def get_DEYdecrementY(self): return self.DEYdecrementY
    def set_DEYdecrementY(self, DEYdecrementY): self.DEYdecrementY = DEYdecrementY
    def get_INYincrementY(self): return self.INYincrementY
    def set_INYincrementY(self, INYincrementY): self.INYincrementY = INYincrementY
    def get_ROLrotateLeft(self): return self.ROLrotateLeft
    def set_ROLrotateLeft(self, ROLrotateLeft): self.ROLrotateLeft = ROLrotateLeft
    def get_RORrotateRight(self): return self.RORrotateRight
    def set_RORrotateRight(self, RORrotateRight): self.RORrotateRight = RORrotateRight
    def get_RTIreturnFromInterrupt(self): return self.RTIreturnFromInterrupt
    def set_RTIreturnFromInterrupt(self, RTIreturnFromInterrupt): self.RTIreturnFromInterrupt = RTIreturnFromInterrupt
    def get_RTSreturnFromSubroutine(self): return self.RTSreturnFromSubroutine
    def set_RTSreturnFromSubroutine(self, RTSreturnFromSubroutine): self.RTSreturnFromSubroutine = RTSreturnFromSubroutine
    def get_SBCSubTractwithCarry(self): return self.SBCSubTractwithCarry
    def set_SBCSubTractwithCarry(self, SBCSubTractwithCarry): self.SBCSubTractwithCarry = SBCSubTractwithCarry
    def get_STAStoreAccumulator(self): return self.STAStoreAccumulator
    def set_STAStoreAccumulator(self, STAStoreAccumulator): self.STAStoreAccumulator = STAStoreAccumulator
    def get_TSXTransferXtoStackptr(self): return self.TSXTransferXtoStackptr
    def set_TSXTransferXtoStackptr(self, TSXTransferXtoStackptr): self.TSXTransferXtoStackptr = TSXTransferXtoStackptr
    def get_TSXTranferStackPtrtoX(self): return self.TSXTranferStackPtrtoX
    def set_TSXTranferStackPtrtoX(self, TSXTranferStackPtrtoX): self.TSXTranferStackPtrtoX = TSXTranferStackPtrtoX
    def get_PHAPushAccumulator(self): return self.PHAPushAccumulator
    def set_PHAPushAccumulator(self, PHAPushAccumulator): self.PHAPushAccumulator = PHAPushAccumulator
    def get_PLApullAccumulator(self): return self.PLApullAccumulator
    def set_PLApullAccumulator(self, PLApullAccumulator): self.PLApullAccumulator = PLApullAccumulator
    def get_PHPpushProcessorStatus(self): return self.PHPpushProcessorStatus
    def set_PHPpushProcessorStatus(self, PHPpushProcessorStatus): self.PHPpushProcessorStatus = PHPpushProcessorStatus
    def get_PLPpullProcessorsStatus(self): return self.PLPpullProcessorsStatus
    def set_PLPpullProcessorsStatus(self, PLPpullProcessorsStatus): self.PLPpullProcessorsStatus = PLPpullProcessorsStatus
    def get_STXstoreXReigster(self): return self.STXstoreXReigster
    def set_STXstoreXReigster(self, STXstoreXReigster): self.STXstoreXReigster = STXstoreXReigster
    def get_STYstoreYRegister(self): return self.STYstoreYRegister
    def set_STYstoreYRegister(self, STYstoreYRegister): self.STYstoreYRegister = STYstoreYRegister
    def export(self, outfile, level, namespace_='', name_='mnemonic', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = []
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='mnemonic')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_, name_, pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='mnemonic'):
        pass
    def exportChildren(self, outfile, level, namespace_='', name_='mnemonic', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.ADCaddWithCarry is not None:
            self.ADCaddWithCarry.export(outfile, level, namespace_, name_='ADCaddWithCarry', pretty_print=pretty_print)
        if self.ANDbitwiseAndWithAccumulator is not None:
            self.ANDbitwiseAndWithAccumulator.export(outfile, level, namespace_, name_='ANDbitwiseAndWithAccumulator', pretty_print=pretty_print)
        if self.ASLartihmeticShiftLeft is not None:
            self.ASLartihmeticShiftLeft.export(outfile, level, namespace_, name_='ASLartihmeticShiftLeft', pretty_print=pretty_print)
        if self.BITtestBits is not None:
            self.BITtestBits.export(outfile, level, namespace_, name_='BITtestBits', pretty_print=pretty_print)
        if self.BPLsetCarry is not None:
            self.BPLsetCarry.export(outfile, level, namespace_, name_='BPLsetCarry', pretty_print=pretty_print)
        if self.BMIbranchonMinus is not None:
            self.BMIbranchonMinus.export(outfile, level, namespace_, name_='BMIbranchonMinus', pretty_print=pretty_print)
        if self.BVCbranchonOverflowClear is not None:
            self.BVCbranchonOverflowClear.export(outfile, level, namespace_, name_='BVCbranchonOverflowClear', pretty_print=pretty_print)
        if self.BVSbranchonOverflowSet is not None:
            self.BVSbranchonOverflowSet.export(outfile, level, namespace_, name_='BVSbranchonOverflowSet', pretty_print=pretty_print)
        if self.BCCbranchonCarryClear is not None:
            self.BCCbranchonCarryClear.export(outfile, level, namespace_, name_='BCCbranchonCarryClear', pretty_print=pretty_print)
        if self.BCSbranchonCarrySet is not None:
            self.BCSbranchonCarrySet.export(outfile, level, namespace_, name_='BCSbranchonCarrySet', pretty_print=pretty_print)
        if self.BEQbranchonEqual is not None:
            self.BEQbranchonEqual.export(outfile, level, namespace_, name_='BEQbranchonEqual', pretty_print=pretty_print)
        if self.BNEbranchonNotequal is not None:
            self.BNEbranchonNotequal.export(outfile, level, namespace_, name_='BNEbranchonNotequal', pretty_print=pretty_print)
        if self.BRKbreak is not None:
            self.BRKbreak.export(outfile, level, namespace_, name_='BRKbreak', pretty_print=pretty_print)
        if self.CMPcompareAccumulator is not None:
            self.CMPcompareAccumulator.export(outfile, level, namespace_, name_='CMPcompareAccumulator', pretty_print=pretty_print)
        if self.CPXcompareXRegister is not None:
            self.CPXcompareXRegister.export(outfile, level, namespace_, name_='CPXcompareXRegister', pretty_print=pretty_print)
        if self.CPYcompareYRegister is not None:
            self.CPYcompareYRegister.export(outfile, level, namespace_, name_='CPYcompareYRegister', pretty_print=pretty_print)
        if self.DECdecrementMemory is not None:
            self.DECdecrementMemory.export(outfile, level, namespace_, name_='DECdecrementMemory', pretty_print=pretty_print)
        if self.EORbitWiseExclusiveOr is not None:
            self.EORbitWiseExclusiveOr.export(outfile, level, namespace_, name_='EORbitWiseExclusiveOr', pretty_print=pretty_print)
        if self.CLClearCarry is not None:
            self.CLClearCarry.export(outfile, level, namespace_, name_='CLClearCarry', pretty_print=pretty_print)
        if self.SECsetCarry is not None:
            self.SECsetCarry.export(outfile, level, namespace_, name_='SECsetCarry', pretty_print=pretty_print)
        if self.SEIsetCarry is not None:
            self.SEIsetCarry.export(outfile, level, namespace_, name_='SEIsetCarry', pretty_print=pretty_print)
        if self.CLIclearInterrupt is not None:
            self.CLIclearInterrupt.export(outfile, level, namespace_, name_='CLIclearInterrupt', pretty_print=pretty_print)
        if self.SEIsetInterrupt is not None:
            self.SEIsetInterrupt.export(outfile, level, namespace_, name_='SEIsetInterrupt', pretty_print=pretty_print)
        if self.CLVclearOverflow is not None:
            self.CLVclearOverflow.export(outfile, level, namespace_, name_='CLVclearOverflow', pretty_print=pretty_print)
        if self.CLDclearDecimal is not None:
            self.CLDclearDecimal.export(outfile, level, namespace_, name_='CLDclearDecimal', pretty_print=pretty_print)
        if self.SEDsetDecimal is not None:
            self.SEDsetDecimal.export(outfile, level, namespace_, name_='SEDsetDecimal', pretty_print=pretty_print)
        if self.INCincrementMemory is not None:
            self.INCincrementMemory.export(outfile, level, namespace_, name_='INCincrementMemory', pretty_print=pretty_print)
        if self.JMPjump is not None:
            self.JMPjump.export(outfile, level, namespace_, name_='JMPjump', pretty_print=pretty_print)
        if self.JSRjumpToSubRoutine is not None:
            self.JSRjumpToSubRoutine.export(outfile, level, namespace_, name_='JSRjumpToSubRoutine', pretty_print=pretty_print)
        if self.LDAloadAccumulator is not None:
            self.LDAloadAccumulator.export(outfile, level, namespace_, name_='LDAloadAccumulator', pretty_print=pretty_print)
        if self.LDXloadXRegister is not None:
            self.LDXloadXRegister.export(outfile, level, namespace_, name_='LDXloadXRegister', pretty_print=pretty_print)
        if self.LDYloadYRegister is not None:
            self.LDYloadYRegister.export(outfile, level, namespace_, name_='LDYloadYRegister', pretty_print=pretty_print)
        if self.LSRlogicalShiftRight is not None:
            self.LSRlogicalShiftRight.export(outfile, level, namespace_, name_='LSRlogicalShiftRight', pretty_print=pretty_print)
        if self.NOPnoOperation is not None:
            self.NOPnoOperation.export(outfile, level, namespace_, name_='NOPnoOperation', pretty_print=pretty_print)
        if self.ORAbitwiseOrWithAccumulator is not None:
            self.ORAbitwiseOrWithAccumulator.export(outfile, level, namespace_, name_='ORAbitwiseOrWithAccumulator', pretty_print=pretty_print)
        if self.TAXTtansferAtoX is not None:
            self.TAXTtansferAtoX.export(outfile, level, namespace_, name_='TAXTtansferAtoX', pretty_print=pretty_print)
        if self.TXAtransferXtoA is not None:
            self.TXAtransferXtoA.export(outfile, level, namespace_, name_='TXAtransferXtoA', pretty_print=pretty_print)
        if self.DEXdecrementX is not None:
            self.DEXdecrementX.export(outfile, level, namespace_, name_='DEXdecrementX', pretty_print=pretty_print)
        if self.INXincrementX is not None:
            self.INXincrementX.export(outfile, level, namespace_, name_='INXincrementX', pretty_print=pretty_print)
        if self.TAYtransferAtoY is not None:
            self.TAYtransferAtoY.export(outfile, level, namespace_, name_='TAYtransferAtoY', pretty_print=pretty_print)
        if self.DEYdecrementY is not None:
            self.DEYdecrementY.export(outfile, level, namespace_, name_='DEYdecrementY', pretty_print=pretty_print)
        if self.INYincrementY is not None:
            self.INYincrementY.export(outfile, level, namespace_, name_='INYincrementY', pretty_print=pretty_print)
        if self.ROLrotateLeft is not None:
            self.ROLrotateLeft.export(outfile, level, namespace_, name_='ROLrotateLeft', pretty_print=pretty_print)
        if self.RORrotateRight is not None:
            self.RORrotateRight.export(outfile, level, namespace_, name_='RORrotateRight', pretty_print=pretty_print)
        if self.RTIreturnFromInterrupt is not None:
            self.RTIreturnFromInterrupt.export(outfile, level, namespace_, name_='RTIreturnFromInterrupt', pretty_print=pretty_print)
        if self.RTSreturnFromSubroutine is not None:
            self.RTSreturnFromSubroutine.export(outfile, level, namespace_, name_='RTSreturnFromSubroutine', pretty_print=pretty_print)
        if self.SBCSubTractwithCarry is not None:
            self.SBCSubTractwithCarry.export(outfile, level, namespace_, name_='SBCSubTractwithCarry', pretty_print=pretty_print)
        if self.STAStoreAccumulator is not None:
            self.STAStoreAccumulator.export(outfile, level, namespace_, name_='STAStoreAccumulator', pretty_print=pretty_print)
        if self.TSXTransferXtoStackptr is not None:
            self.TSXTransferXtoStackptr.export(outfile, level, namespace_, name_='TSXTransferXtoStackptr', pretty_print=pretty_print)
        if self.TSXTranferStackPtrtoX is not None:
            self.TSXTranferStackPtrtoX.export(outfile, level, namespace_, name_='TSXTranferStackPtrtoX', pretty_print=pretty_print)
        if self.PHAPushAccumulator is not None:
            self.PHAPushAccumulator.export(outfile, level, namespace_, name_='PHAPushAccumulator', pretty_print=pretty_print)
        if self.PLApullAccumulator is not None:
            self.PLApullAccumulator.export(outfile, level, namespace_, name_='PLApullAccumulator', pretty_print=pretty_print)
        if self.PHPpushProcessorStatus is not None:
            self.PHPpushProcessorStatus.export(outfile, level, namespace_, name_='PHPpushProcessorStatus', pretty_print=pretty_print)
        if self.PLPpullProcessorsStatus is not None:
            self.PLPpullProcessorsStatus.export(outfile, level, namespace_, name_='PLPpullProcessorsStatus', pretty_print=pretty_print)
        if self.STXstoreXReigster is not None:
            self.STXstoreXReigster.export(outfile, level, namespace_, name_='STXstoreXReigster', pretty_print=pretty_print)
        if self.STYstoreYRegister is not None:
            self.STYstoreYRegister.export(outfile, level, namespace_, name_='STYstoreYRegister', pretty_print=pretty_print)
    def hasContent_(self):
        if (
            self.ADCaddWithCarry is not None or
            self.ANDbitwiseAndWithAccumulator is not None or
            self.ASLartihmeticShiftLeft is not None or
            self.BITtestBits is not None or
            self.BPLsetCarry is not None or
            self.BMIbranchonMinus is not None or
            self.BVCbranchonOverflowClear is not None or
            self.BVSbranchonOverflowSet is not None or
            self.BCCbranchonCarryClear is not None or
            self.BCSbranchonCarrySet is not None or
            self.BEQbranchonEqual is not None or
            self.BNEbranchonNotequal is not None or
            self.BRKbreak is not None or
            self.CMPcompareAccumulator is not None or
            self.CPXcompareXRegister is not None or
            self.CPYcompareYRegister is not None or
            self.DECdecrementMemory is not None or
            self.EORbitWiseExclusiveOr is not None or
            self.CLClearCarry is not None or
            self.SECsetCarry is not None or
            self.SEIsetCarry is not None or
            self.CLIclearInterrupt is not None or
            self.SEIsetInterrupt is not None or
            self.CLVclearOverflow is not None or
            self.CLDclearDecimal is not None or
            self.SEDsetDecimal is not None or
            self.INCincrementMemory is not None or
            self.JMPjump is not None or
            self.JSRjumpToSubRoutine is not None or
            self.LDAloadAccumulator is not None or
            self.LDXloadXRegister is not None or
            self.LDYloadYRegister is not None or
            self.LSRlogicalShiftRight is not None or
            self.NOPnoOperation is not None or
            self.ORAbitwiseOrWithAccumulator is not None or
            self.TAXTtansferAtoX is not None or
            self.TXAtransferXtoA is not None or
            self.DEXdecrementX is not None or
            self.INXincrementX is not None or
            self.TAYtransferAtoY is not None or
            self.DEYdecrementY is not None or
            self.INYincrementY is not None or
            self.ROLrotateLeft is not None or
            self.RORrotateRight is not None or
            self.RTIreturnFromInterrupt is not None or
            self.RTSreturnFromSubroutine is not None or
            self.SBCSubTractwithCarry is not None or
            self.STAStoreAccumulator is not None or
            self.TSXTransferXtoStackptr is not None or
            self.TSXTranferStackPtrtoX is not None or
            self.PHAPushAccumulator is not None or
            self.PLApullAccumulator is not None or
            self.PHPpushProcessorStatus is not None or
            self.PLPpullProcessorsStatus is not None or
            self.STXstoreXReigster is not None or
            self.STYstoreYRegister is not None
            ):
            return True
        else:
            return False
    def exportLiteral(self, outfile, level, name_='mnemonic'):
        level += 1
        self.exportLiteralAttributes(outfile, level, [], name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        pass
    def exportLiteralChildren(self, outfile, level, name_):
        if self.ADCaddWithCarry is not None:
            showIndent(outfile, level)
            outfile.write('ADCaddWithCarry=model_.ADCaddWithCarry(\n')
            self.ADCaddWithCarry.exportLiteral(outfile, level)
            showIndent(outfile, level)
            outfile.write('),\n')
        if self.ANDbitwiseAndWithAccumulator is not None:
            showIndent(outfile, level)
            outfile.write('ANDbitwiseAndWithAccumulator=model_.ANDbitwiseAndWithAccumulator(\n')
            self.ANDbitwiseAndWithAccumulator.exportLiteral(outfile, level)
            showIndent(outfile, level)
            outfile.write('),\n')
        if self.ASLartihmeticShiftLeft is not None:
            showIndent(outfile, level)
            outfile.write('ASLartihmeticShiftLeft=model_.ASLartihmeticShiftLeft(\n')
            self.ASLartihmeticShiftLeft.exportLiteral(outfile, level)
            showIndent(outfile, level)
            outfile.write('),\n')
        if self.BITtestBits is not None:
            showIndent(outfile, level)
            outfile.write('BITtestBits=model_.BITtestBits(\n')
            self.BITtestBits.exportLiteral(outfile, level)
            showIndent(outfile, level)
            outfile.write('),\n')
        if self.BPLsetCarry is not None:
            showIndent(outfile, level)
            outfile.write('BPLsetCarry=model_.BPLsetCarry(\n')
            self.BPLsetCarry.exportLiteral(outfile, level)
            showIndent(outfile, level)
            outfile.write('),\n')
        if self.BMIbranchonMinus is not None:
            showIndent(outfile, level)
            outfile.write('BMIbranchonMinus=model_.BMIbranchonMinus(\n')
            self.BMIbranchonMinus.exportLiteral(outfile, level)
            showIndent(outfile, level)
            outfile.write('),\n')
        if self.BVCbranchonOverflowClear is not None:
            showIndent(outfile, level)
            outfile.write('BVCbranchonOverflowClear=model_.BVCbranchonOverflowClear(\n')
            self.BVCbranchonOverflowClear.exportLiteral(outfile, level)
            showIndent(outfile, level)
            outfile.write('),\n')
        if self.BVSbranchonOverflowSet is not None:
            showIndent(outfile, level)
            outfile.write('BVSbranchonOverflowSet=model_.BVSbranchonOverflowSet(\n')
            self.BVSbranchonOverflowSet.exportLiteral(outfile, level)
            showIndent(outfile, level)
            outfile.write('),\n')
        if self.BCCbranchonCarryClear is not None:
            showIndent(outfile, level)
            outfile.write('BCCbranchonCarryClear=model_.BCCbranchonCarryClear(\n')
            self.BCCbranchonCarryClear.exportLiteral(outfile, level)
            showIndent(outfile, level)
            outfile.write('),\n')
        if self.BCSbranchonCarrySet is not None:
            showIndent(outfile, level)
            outfile.write('BCSbranchonCarrySet=model_.BCSbranchonCarrySet(\n')
            self.BCSbranchonCarrySet.exportLiteral(outfile, level)
            showIndent(outfile, level)
            outfile.write('),\n')
        if self.BEQbranchonEqual is not None:
            showIndent(outfile, level)
            outfile.write('BEQbranchonEqual=model_.BEQbranchonEqual(\n')
            self.BEQbranchonEqual.exportLiteral(outfile, level)
            showIndent(outfile, level)
            outfile.write('),\n')
        if self.BNEbranchonNotequal is not None:
            showIndent(outfile, level)
            outfile.write('BNEbranchonNotequal=model_.BNEbranchonNotequal(\n')
            self.BNEbranchonNotequal.exportLiteral(outfile, level)
            showIndent(outfile, level)
            outfile.write('),\n')
        if self.BRKbreak is not None:
            showIndent(outfile, level)
            outfile.write('BRKbreak=model_.BRKbreak(\n')
            self.BRKbreak.exportLiteral(outfile, level)
            showIndent(outfile, level)
            outfile.write('),\n')
        if self.CMPcompareAccumulator is not None:
            showIndent(outfile, level)
            outfile.write('CMPcompareAccumulator=model_.CMPcompareAccumulator(\n')
            self.CMPcompareAccumulator.exportLiteral(outfile, level)
            showIndent(outfile, level)
            outfile.write('),\n')
        if self.CPXcompareXRegister is not None:
            showIndent(outfile, level)
            outfile.write('CPXcompareXRegister=model_.CPXcompareXRegister(\n')
            self.CPXcompareXRegister.exportLiteral(outfile, level)
            showIndent(outfile, level)
            outfile.write('),\n')
        if self.CPYcompareYRegister is not None:
            showIndent(outfile, level)
            outfile.write('CPYcompareYRegister=model_.CPYcompareYRegister(\n')
            self.CPYcompareYRegister.exportLiteral(outfile, level)
            showIndent(outfile, level)
            outfile.write('),\n')
        if self.DECdecrementMemory is not None:
            showIndent(outfile, level)
            outfile.write('DECdecrementMemory=model_.DECdecrementMemory(\n')
            self.DECdecrementMemory.exportLiteral(outfile, level)
            showIndent(outfile, level)
            outfile.write('),\n')
        if self.EORbitWiseExclusiveOr is not None:
            showIndent(outfile, level)
            outfile.write('EORbitWiseExclusiveOr=model_.EORbitWiseExclusiveOr(\n')
            self.EORbitWiseExclusiveOr.exportLiteral(outfile, level)
            showIndent(outfile, level)
            outfile.write('),\n')
        if self.CLClearCarry is not None:
            showIndent(outfile, level)
            outfile.write('CLClearCarry=model_.CLClearCarry(\n')
            self.CLClearCarry.exportLiteral(outfile, level)
            showIndent(outfile, level)
            outfile.write('),\n')
        if self.SECsetCarry is not None:
            showIndent(outfile, level)
            outfile.write('SECsetCarry=model_.SECsetCarry(\n')
            self.SECsetCarry.exportLiteral(outfile, level)
            showIndent(outfile, level)
            outfile.write('),\n')
        if self.SEIsetCarry is not None:
            showIndent(outfile, level)
            outfile.write('SEIsetCarry=model_.SEIsetCarry(\n')
            self.SEIsetCarry.exportLiteral(outfile, level)
            showIndent(outfile, level)
            outfile.write('),\n')
        if self.CLIclearInterrupt is not None:
            showIndent(outfile, level)
            outfile.write('CLIclearInterrupt=model_.CLIclearInterrupt(\n')
            self.CLIclearInterrupt.exportLiteral(outfile, level)
            showIndent(outfile, level)
            outfile.write('),\n')
        if self.SEIsetInterrupt is not None:
            showIndent(outfile, level)
            outfile.write('SEIsetInterrupt=model_.SEIsetInterrupt(\n')
            self.SEIsetInterrupt.exportLiteral(outfile, level)
            showIndent(outfile, level)
            outfile.write('),\n')
        if self.CLVclearOverflow is not None:
            showIndent(outfile, level)
            outfile.write('CLVclearOverflow=model_.CLVclearOverflow(\n')
            self.CLVclearOverflow.exportLiteral(outfile, level)
            showIndent(outfile, level)
            outfile.write('),\n')
        if self.CLDclearDecimal is not None:
            showIndent(outfile, level)
            outfile.write('CLDclearDecimal=model_.CLDclearDecimal(\n')
            self.CLDclearDecimal.exportLiteral(outfile, level)
            showIndent(outfile, level)
            outfile.write('),\n')
        if self.SEDsetDecimal is not None:
            showIndent(outfile, level)
            outfile.write('SEDsetDecimal=model_.SEDsetDecimal(\n')
            self.SEDsetDecimal.exportLiteral(outfile, level)
            showIndent(outfile, level)
            outfile.write('),\n')
        if self.INCincrementMemory is not None:
            showIndent(outfile, level)
            outfile.write('INCincrementMemory=model_.INCincrementMemory(\n')
            self.INCincrementMemory.exportLiteral(outfile, level)
            showIndent(outfile, level)
            outfile.write('),\n')
        if self.JMPjump is not None:
            showIndent(outfile, level)
            outfile.write('JMPjump=model_.JMPjump(\n')
            self.JMPjump.exportLiteral(outfile, level)
            showIndent(outfile, level)
            outfile.write('),\n')
        if self.JSRjumpToSubRoutine is not None:
            showIndent(outfile, level)
            outfile.write('JSRjumpToSubRoutine=model_.JSRjumpToSubRoutine(\n')
            self.JSRjumpToSubRoutine.exportLiteral(outfile, level)
            showIndent(outfile, level)
            outfile.write('),\n')
        if self.LDAloadAccumulator is not None:
            showIndent(outfile, level)
            outfile.write('LDAloadAccumulator=model_.LDAloadAccumulator(\n')
            self.LDAloadAccumulator.exportLiteral(outfile, level)
            showIndent(outfile, level)
            outfile.write('),\n')
        if self.LDXloadXRegister is not None:
            showIndent(outfile, level)
            outfile.write('LDXloadXRegister=model_.LDXloadXRegister(\n')
            self.LDXloadXRegister.exportLiteral(outfile, level)
            showIndent(outfile, level)
            outfile.write('),\n')
        if self.LDYloadYRegister is not None:
            showIndent(outfile, level)
            outfile.write('LDYloadYRegister=model_.LDYloadYRegister(\n')
            self.LDYloadYRegister.exportLiteral(outfile, level)
            showIndent(outfile, level)
            outfile.write('),\n')
        if self.LSRlogicalShiftRight is not None:
            showIndent(outfile, level)
            outfile.write('LSRlogicalShiftRight=model_.LSRlogicalShiftRight(\n')
            self.LSRlogicalShiftRight.exportLiteral(outfile, level)
            showIndent(outfile, level)
            outfile.write('),\n')
        if self.NOPnoOperation is not None:
            showIndent(outfile, level)
            outfile.write('NOPnoOperation=model_.NOPnoOperation(\n')
            self.NOPnoOperation.exportLiteral(outfile, level)
            showIndent(outfile, level)
            outfile.write('),\n')
        if self.ORAbitwiseOrWithAccumulator is not None:
            showIndent(outfile, level)
            outfile.write('ORAbitwiseOrWithAccumulator=model_.ORAbitwiseOrWithAccumulator(\n')
            self.ORAbitwiseOrWithAccumulator.exportLiteral(outfile, level)
            showIndent(outfile, level)
            outfile.write('),\n')
        if self.TAXTtansferAtoX is not None:
            showIndent(outfile, level)
            outfile.write('TAXTtansferAtoX=model_.TAXTtansferAtoX(\n')
            self.TAXTtansferAtoX.exportLiteral(outfile, level)
            showIndent(outfile, level)
            outfile.write('),\n')
        if self.TXAtransferXtoA is not None:
            showIndent(outfile, level)
            outfile.write('TXAtransferXtoA=model_.TXAtransferXtoA(\n')
            self.TXAtransferXtoA.exportLiteral(outfile, level)
            showIndent(outfile, level)
            outfile.write('),\n')
        if self.DEXdecrementX is not None:
            showIndent(outfile, level)
            outfile.write('DEXdecrementX=model_.DEXdecrementX(\n')
            self.DEXdecrementX.exportLiteral(outfile, level)
            showIndent(outfile, level)
            outfile.write('),\n')
        if self.INXincrementX is not None:
            showIndent(outfile, level)
            outfile.write('INXincrementX=model_.INXincrementX(\n')
            self.INXincrementX.exportLiteral(outfile, level)
            showIndent(outfile, level)
            outfile.write('),\n')
        if self.TAYtransferAtoY is not None:
            showIndent(outfile, level)
            outfile.write('TAYtransferAtoY=model_.TAYtransferAtoY(\n')
            self.TAYtransferAtoY.exportLiteral(outfile, level)
            showIndent(outfile, level)
            outfile.write('),\n')
        if self.DEYdecrementY is not None:
            showIndent(outfile, level)
            outfile.write('DEYdecrementY=model_.DEYdecrementY(\n')
            self.DEYdecrementY.exportLiteral(outfile, level)
            showIndent(outfile, level)
            outfile.write('),\n')
        if self.INYincrementY is not None:
            showIndent(outfile, level)
            outfile.write('INYincrementY=model_.INYincrementY(\n')
            self.INYincrementY.exportLiteral(outfile, level)
            showIndent(outfile, level)
            outfile.write('),\n')
        if self.ROLrotateLeft is not None:
            showIndent(outfile, level)
            outfile.write('ROLrotateLeft=model_.ROLrotateLeft(\n')
            self.ROLrotateLeft.exportLiteral(outfile, level)
            showIndent(outfile, level)
            outfile.write('),\n')
        if self.RORrotateRight is not None:
            showIndent(outfile, level)
            outfile.write('RORrotateRight=model_.RORrotateRight(\n')
            self.RORrotateRight.exportLiteral(outfile, level)
            showIndent(outfile, level)
            outfile.write('),\n')
        if self.RTIreturnFromInterrupt is not None:
            showIndent(outfile, level)
            outfile.write('RTIreturnFromInterrupt=model_.RTIreturnFromInterrupt(\n')
            self.RTIreturnFromInterrupt.exportLiteral(outfile, level)
            showIndent(outfile, level)
            outfile.write('),\n')
        if self.RTSreturnFromSubroutine is not None:
            showIndent(outfile, level)
            outfile.write('RTSreturnFromSubroutine=model_.RTSreturnFromSubroutine(\n')
            self.RTSreturnFromSubroutine.exportLiteral(outfile, level)
            showIndent(outfile, level)
            outfile.write('),\n')
        if self.SBCSubTractwithCarry is not None:
            showIndent(outfile, level)
            outfile.write('SBCSubTractwithCarry=model_.SBCSubTractwithCarry(\n')
            self.SBCSubTractwithCarry.exportLiteral(outfile, level)
            showIndent(outfile, level)
            outfile.write('),\n')
        if self.STAStoreAccumulator is not None:
            showIndent(outfile, level)
            outfile.write('STAStoreAccumulator=model_.STAStoreAccumulator(\n')
            self.STAStoreAccumulator.exportLiteral(outfile, level)
            showIndent(outfile, level)
            outfile.write('),\n')
        if self.TSXTransferXtoStackptr is not None:
            showIndent(outfile, level)
            outfile.write('TSXTransferXtoStackptr=model_.TSXTransferXtoStackptr(\n')
            self.TSXTransferXtoStackptr.exportLiteral(outfile, level)
            showIndent(outfile, level)
            outfile.write('),\n')
        if self.TSXTranferStackPtrtoX is not None:
            showIndent(outfile, level)
            outfile.write('TSXTranferStackPtrtoX=model_.TSXTranferStackPtrtoX(\n')
            self.TSXTranferStackPtrtoX.exportLiteral(outfile, level)
            showIndent(outfile, level)
            outfile.write('),\n')
        if self.PHAPushAccumulator is not None:
            showIndent(outfile, level)
            outfile.write('PHAPushAccumulator=model_.PHAPushAccumulator(\n')
            self.PHAPushAccumulator.exportLiteral(outfile, level)
            showIndent(outfile, level)
            outfile.write('),\n')
        if self.PLApullAccumulator is not None:
            showIndent(outfile, level)
            outfile.write('PLApullAccumulator=model_.PLApullAccumulator(\n')
            self.PLApullAccumulator.exportLiteral(outfile, level)
            showIndent(outfile, level)
            outfile.write('),\n')
        if self.PHPpushProcessorStatus is not None:
            showIndent(outfile, level)
            outfile.write('PHPpushProcessorStatus=model_.PHPpushProcessorStatus(\n')
            self.PHPpushProcessorStatus.exportLiteral(outfile, level)
            showIndent(outfile, level)
            outfile.write('),\n')
        if self.PLPpullProcessorsStatus is not None:
            showIndent(outfile, level)
            outfile.write('PLPpullProcessorsStatus=model_.PLPpullProcessorsStatus(\n')
            self.PLPpullProcessorsStatus.exportLiteral(outfile, level)
            showIndent(outfile, level)
            outfile.write('),\n')
        if self.STXstoreXReigster is not None:
            showIndent(outfile, level)
            outfile.write('STXstoreXReigster=model_.STXstoreXReigster(\n')
            self.STXstoreXReigster.exportLiteral(outfile, level)
            showIndent(outfile, level)
            outfile.write('),\n')
        if self.STYstoreYRegister is not None:
            showIndent(outfile, level)
            outfile.write('STYstoreYRegister=model_.STYstoreYRegister(\n')
            self.STYstoreYRegister.exportLiteral(outfile, level)
            showIndent(outfile, level)
            outfile.write('),\n')
    def build(self, node):
        self.buildAttributes(node, node.attrib, [])
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'ADCaddWithCarry':
            obj_ = ADCaddWithCarry.factory()
            obj_.build(child_)
            self.set_ADCaddWithCarry(obj_)
        elif nodeName_ == 'ANDbitwiseAndWithAccumulator':
            obj_ = ANDbitwiseAndWithAccumulator.factory()
            obj_.build(child_)
            self.set_ANDbitwiseAndWithAccumulator(obj_)
        elif nodeName_ == 'ASLartihmeticShiftLeft':
            obj_ = ASLartihmeticShiftLeft.factory()
            obj_.build(child_)
            self.set_ASLartihmeticShiftLeft(obj_)
        elif nodeName_ == 'BITtestBits':
            obj_ = BITtestBits.factory()
            obj_.build(child_)
            self.set_BITtestBits(obj_)
        elif nodeName_ == 'BPLsetCarry':
            obj_ = BPLsetCarry.factory()
            obj_.build(child_)
            self.set_BPLsetCarry(obj_)
        elif nodeName_ == 'BMIbranchonMinus':
            obj_ = BMIbranchonMinus.factory()
            obj_.build(child_)
            self.set_BMIbranchonMinus(obj_)
        elif nodeName_ == 'BVCbranchonOverflowClear':
            obj_ = BVCbranchonOverflowClear.factory()
            obj_.build(child_)
            self.set_BVCbranchonOverflowClear(obj_)
        elif nodeName_ == 'BVSbranchonOverflowSet':
            obj_ = BVSbranchonOverflowSet.factory()
            obj_.build(child_)
            self.set_BVSbranchonOverflowSet(obj_)
        elif nodeName_ == 'BCCbranchonCarryClear':
            obj_ = BCCbranchonCarryClear.factory()
            obj_.build(child_)
            self.set_BCCbranchonCarryClear(obj_)
        elif nodeName_ == 'BCSbranchonCarrySet':
            obj_ = BCSbranchonCarrySet.factory()
            obj_.build(child_)
            self.set_BCSbranchonCarrySet(obj_)
        elif nodeName_ == 'BEQbranchonEqual':
            obj_ = BEQbranchonEqual.factory()
            obj_.build(child_)
            self.set_BEQbranchonEqual(obj_)
        elif nodeName_ == 'BNEbranchonNotequal':
            obj_ = BNEbranchonNotequal.factory()
            obj_.build(child_)
            self.set_BNEbranchonNotequal(obj_)
        elif nodeName_ == 'BRKbreak':
            obj_ = BRKbreak.factory()
            obj_.build(child_)
            self.set_BRKbreak(obj_)
        elif nodeName_ == 'CMPcompareAccumulator':
            obj_ = CMPcompareAccumulator.factory()
            obj_.build(child_)
            self.set_CMPcompareAccumulator(obj_)
        elif nodeName_ == 'CPXcompareXRegister':
            obj_ = CPXcompareXRegister.factory()
            obj_.build(child_)
            self.set_CPXcompareXRegister(obj_)
        elif nodeName_ == 'CPYcompareYRegister':
            obj_ = CPYcompareYRegister.factory()
            obj_.build(child_)
            self.set_CPYcompareYRegister(obj_)
        elif nodeName_ == 'DECdecrementMemory':
            obj_ = DECdecrementMemory.factory()
            obj_.build(child_)
            self.set_DECdecrementMemory(obj_)
        elif nodeName_ == 'EORbitWiseExclusiveOr':
            obj_ = EORbitWiseExclusiveOr.factory()
            obj_.build(child_)
            self.set_EORbitWiseExclusiveOr(obj_)
        elif nodeName_ == 'CLClearCarry':
            obj_ = CLClearCarry.factory()
            obj_.build(child_)
            self.set_CLClearCarry(obj_)
        elif nodeName_ == 'SECsetCarry':
            obj_ = SECsetCarry.factory()
            obj_.build(child_)
            self.set_SECsetCarry(obj_)
        elif nodeName_ == 'SEIsetCarry':
            obj_ = SEIsetCarry.factory()
            obj_.build(child_)
            self.set_SEIsetCarry(obj_)
        elif nodeName_ == 'CLIclearInterrupt':
            obj_ = CLIclearInterrupt.factory()
            obj_.build(child_)
            self.set_CLIclearInterrupt(obj_)
        elif nodeName_ == 'SEIsetInterrupt':
            obj_ = SEIsetInterrupt.factory()
            obj_.build(child_)
            self.set_SEIsetInterrupt(obj_)
        elif nodeName_ == 'CLVclearOverflow':
            obj_ = CLVclearOverflow.factory()
            obj_.build(child_)
            self.set_CLVclearOverflow(obj_)
        elif nodeName_ == 'CLDclearDecimal':
            obj_ = CLDclearDecimal.factory()
            obj_.build(child_)
            self.set_CLDclearDecimal(obj_)
        elif nodeName_ == 'SEDsetDecimal':
            obj_ = SEDsetDecimal.factory()
            obj_.build(child_)
            self.set_SEDsetDecimal(obj_)
        elif nodeName_ == 'INCincrementMemory':
            obj_ = INCincrementMemory.factory()
            obj_.build(child_)
            self.set_INCincrementMemory(obj_)
        elif nodeName_ == 'JMPjump':
            obj_ = JMPjump.factory()
            obj_.build(child_)
            self.set_JMPjump(obj_)
        elif nodeName_ == 'JSRjumpToSubRoutine':
            obj_ = JSRjumpToSubRoutine.factory()
            obj_.build(child_)
            self.set_JSRjumpToSubRoutine(obj_)
        elif nodeName_ == 'LDAloadAccumulator':
            obj_ = LDAloadAccumulator.factory()
            obj_.build(child_)
            self.set_LDAloadAccumulator(obj_)
        elif nodeName_ == 'LDXloadXRegister':
            obj_ = LDXloadXRegister.factory()
            obj_.build(child_)
            self.set_LDXloadXRegister(obj_)
        elif nodeName_ == 'LDYloadYRegister':
            obj_ = LDYloadYRegister.factory()
            obj_.build(child_)
            self.set_LDYloadYRegister(obj_)
        elif nodeName_ == 'LSRlogicalShiftRight':
            obj_ = LSRlogicalShiftRight.factory()
            obj_.build(child_)
            self.set_LSRlogicalShiftRight(obj_)
        elif nodeName_ == 'NOPnoOperation':
            obj_ = NOPnoOperation.factory()
            obj_.build(child_)
            self.set_NOPnoOperation(obj_)
        elif nodeName_ == 'ORAbitwiseOrWithAccumulator':
            obj_ = ORAbitwiseOrWithAccumulator.factory()
            obj_.build(child_)
            self.set_ORAbitwiseOrWithAccumulator(obj_)
        elif nodeName_ == 'TAXTtansferAtoX':
            obj_ = TAXTtansferAtoX.factory()
            obj_.build(child_)
            self.set_TAXTtansferAtoX(obj_)
        elif nodeName_ == 'TXAtransferXtoA':
            obj_ = TXAtransferXtoA.factory()
            obj_.build(child_)
            self.set_TXAtransferXtoA(obj_)
        elif nodeName_ == 'DEXdecrementX':
            obj_ = DEXdecrementX.factory()
            obj_.build(child_)
            self.set_DEXdecrementX(obj_)
        elif nodeName_ == 'INXincrementX':
            obj_ = INXincrementX.factory()
            obj_.build(child_)
            self.set_INXincrementX(obj_)
        elif nodeName_ == 'TAYtransferAtoY':
            obj_ = TAYtransferAtoY.factory()
            obj_.build(child_)
            self.set_TAYtransferAtoY(obj_)
        elif nodeName_ == 'DEYdecrementY':
            obj_ = DEYdecrementY.factory()
            obj_.build(child_)
            self.set_DEYdecrementY(obj_)
        elif nodeName_ == 'INYincrementY':
            obj_ = INYincrementY.factory()
            obj_.build(child_)
            self.set_INYincrementY(obj_)
        elif nodeName_ == 'ROLrotateLeft':
            obj_ = ROLrotateLeft.factory()
            obj_.build(child_)
            self.set_ROLrotateLeft(obj_)
        elif nodeName_ == 'RORrotateRight':
            obj_ = RORrotateRight.factory()
            obj_.build(child_)
            self.set_RORrotateRight(obj_)
        elif nodeName_ == 'RTIreturnFromInterrupt':
            obj_ = RTIreturnFromInterrupt.factory()
            obj_.build(child_)
            self.set_RTIreturnFromInterrupt(obj_)
        elif nodeName_ == 'RTSreturnFromSubroutine':
            obj_ = RTSreturnFromSubroutine.factory()
            obj_.build(child_)
            self.set_RTSreturnFromSubroutine(obj_)
        elif nodeName_ == 'SBCSubTractwithCarry':
            obj_ = SBCSubTractwithCarry.factory()
            obj_.build(child_)
            self.set_SBCSubTractwithCarry(obj_)
        elif nodeName_ == 'STAStoreAccumulator':
            obj_ = STAStoreAccumulator.factory()
            obj_.build(child_)
            self.set_STAStoreAccumulator(obj_)
        elif nodeName_ == 'TSXTransferXtoStackptr':
            obj_ = TSXTransferXtoStackptr.factory()
            obj_.build(child_)
            self.set_TSXTransferXtoStackptr(obj_)
        elif nodeName_ == 'TSXTranferStackPtrtoX':
            obj_ = TSXTranferStackPtrtoX.factory()
            obj_.build(child_)
            self.set_TSXTranferStackPtrtoX(obj_)
        elif nodeName_ == 'PHAPushAccumulator':
            obj_ = PHAPushAccumulator.factory()
            obj_.build(child_)
            self.set_PHAPushAccumulator(obj_)
        elif nodeName_ == 'PLApullAccumulator':
            obj_ = PLApullAccumulator.factory()
            obj_.build(child_)
            self.set_PLApullAccumulator(obj_)
        elif nodeName_ == 'PHPpushProcessorStatus':
            obj_ = PHPpushProcessorStatus.factory()
            obj_.build(child_)
            self.set_PHPpushProcessorStatus(obj_)
        elif nodeName_ == 'PLPpullProcessorsStatus':
            obj_ = PLPpullProcessorsStatus.factory()
            obj_.build(child_)
            self.set_PLPpullProcessorsStatus(obj_)
        elif nodeName_ == 'STXstoreXReigster':
            obj_ = STXstoreXReigster.factory()
            obj_.build(child_)
            self.set_STXstoreXReigster(obj_)
        elif nodeName_ == 'STYstoreYRegister':
            obj_ = STYstoreYRegister.factory()
            obj_.build(child_)
            self.set_STYstoreYRegister(obj_)
# end class mnemonic


class ADCaddWithCarry(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, name=None, value=None, comment=None):
        self.name = name
        if value is None:
            self.value = []
        else:
            self.value = value
        self.comment = comment
    def factory(*args_, **kwargs_):
        if ADCaddWithCarry.subclass:
            return ADCaddWithCarry.subclass(*args_, **kwargs_)
        else:
            return ADCaddWithCarry(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_name(self): return self.name
    def set_name(self, name): self.name = name
    def get_value(self): return self.value
    def set_value(self, value): self.value = value
    def add_value(self, value): self.value.append(value)
    def insert_value(self, index, value): self.value[index] = value
    def get_comment(self): return self.comment
    def set_comment(self, comment): self.comment = comment
    def export(self, outfile, level, namespace_='', name_='ADCaddWithCarry', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = []
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='ADCaddWithCarry')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_, name_, pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='ADCaddWithCarry'):
        pass
    def exportChildren(self, outfile, level, namespace_='', name_='ADCaddWithCarry', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.name is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sname>%s</%sname>%s' % (namespace_, self.gds_format_string(quote_xml(self.name).encode(ExternalEncoding), input_name='name'), namespace_, eol_))
        for value_ in self.value:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%svalue>%s</%svalue>%s' % (namespace_, self.gds_format_string(quote_xml(value_).encode(ExternalEncoding), input_name='value'), namespace_, eol_))
        if self.comment is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%scomment>%s</%scomment>%s' % (namespace_, self.gds_format_string(quote_xml(self.comment).encode(ExternalEncoding), input_name='comment'), namespace_, eol_))
    def hasContent_(self):
        if (
            self.name is not None or
            self.value or
            self.comment is not None
            ):
            return True
        else:
            return False
    def exportLiteral(self, outfile, level, name_='ADCaddWithCarry'):
        level += 1
        self.exportLiteralAttributes(outfile, level, [], name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        pass
    def exportLiteralChildren(self, outfile, level, name_):
        if self.name is not None:
            showIndent(outfile, level)
            outfile.write('name=%s,\n' % quote_python(self.name).encode(ExternalEncoding))
        showIndent(outfile, level)
        outfile.write('value=[\n')
        level += 1
        for value_ in self.value:
            showIndent(outfile, level)
            outfile.write('%s,\n' % quote_python(value_).encode(ExternalEncoding))
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
        if self.comment is not None:
            showIndent(outfile, level)
            outfile.write('comment=%s,\n' % quote_python(self.comment).encode(ExternalEncoding))
    def build(self, node):
        self.buildAttributes(node, node.attrib, [])
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'name':
            name_ = child_.text
            name_ = re_.sub(String_cleanup_pat_, " ", name_).strip()
            name_ = self.gds_validate_string(name_, node, 'name')
            self.name = name_
        elif nodeName_ == 'value':
            value_ = child_.text
            value_ = self.gds_validate_string(value_, node, 'value')
            self.value.append(value_)
        elif nodeName_ == 'comment':
            comment_ = child_.text
            comment_ = self.gds_validate_string(comment_, node, 'comment')
            self.comment = comment_
# end class ADCaddWithCarry


class name(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self):
        pass
    def factory(*args_, **kwargs_):
        if name.subclass:
            return name.subclass(*args_, **kwargs_)
        else:
            return name(*args_, **kwargs_)
    factory = staticmethod(factory)
    def export(self, outfile, level, namespace_='', name_='name', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = []
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='name')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_, name_, pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='name'):
        pass
    def exportChildren(self, outfile, level, namespace_='', name_='name', fromsubclass_=False, pretty_print=True):
        pass
    def hasContent_(self):
        if (

            ):
            return True
        else:
            return False
    def exportLiteral(self, outfile, level, name_='name'):
        level += 1
        self.exportLiteralAttributes(outfile, level, [], name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        pass
    def exportLiteralChildren(self, outfile, level, name_):
        pass
    def build(self, node):
        self.buildAttributes(node, node.attrib, [])
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        pass
# end class name


class ANDbitwiseAndWithAccumulator(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, name=None, value=None, comment=None):
        self.name = name
        if value is None:
            self.value = []
        else:
            self.value = value
        self.comment = comment
    def factory(*args_, **kwargs_):
        if ANDbitwiseAndWithAccumulator.subclass:
            return ANDbitwiseAndWithAccumulator.subclass(*args_, **kwargs_)
        else:
            return ANDbitwiseAndWithAccumulator(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_name(self): return self.name
    def set_name(self, name): self.name = name
    def get_value(self): return self.value
    def set_value(self, value): self.value = value
    def add_value(self, value): self.value.append(value)
    def insert_value(self, index, value): self.value[index] = value
    def get_comment(self): return self.comment
    def set_comment(self, comment): self.comment = comment
    def export(self, outfile, level, namespace_='', name_='ANDbitwiseAndWithAccumulator', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = []
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='ANDbitwiseAndWithAccumulator')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_, name_, pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='ANDbitwiseAndWithAccumulator'):
        pass
    def exportChildren(self, outfile, level, namespace_='', name_='ANDbitwiseAndWithAccumulator', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.name is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sname>%s</%sname>%s' % (namespace_, self.gds_format_string(quote_xml(self.name).encode(ExternalEncoding), input_name='name'), namespace_, eol_))
        for value_ in self.value:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%svalue>%s</%svalue>%s' % (namespace_, self.gds_format_string(quote_xml(value_).encode(ExternalEncoding), input_name='value'), namespace_, eol_))
        if self.comment is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%scomment>%s</%scomment>%s' % (namespace_, self.gds_format_string(quote_xml(self.comment).encode(ExternalEncoding), input_name='comment'), namespace_, eol_))
    def hasContent_(self):
        if (
            self.name is not None or
            self.value or
            self.comment is not None
            ):
            return True
        else:
            return False
    def exportLiteral(self, outfile, level, name_='ANDbitwiseAndWithAccumulator'):
        level += 1
        self.exportLiteralAttributes(outfile, level, [], name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        pass
    def exportLiteralChildren(self, outfile, level, name_):
        if self.name is not None:
            showIndent(outfile, level)
            outfile.write('name=%s,\n' % quote_python(self.name).encode(ExternalEncoding))
        showIndent(outfile, level)
        outfile.write('value=[\n')
        level += 1
        for value_ in self.value:
            showIndent(outfile, level)
            outfile.write('%s,\n' % quote_python(value_).encode(ExternalEncoding))
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
        if self.comment is not None:
            showIndent(outfile, level)
            outfile.write('comment=%s,\n' % quote_python(self.comment).encode(ExternalEncoding))
    def build(self, node):
        self.buildAttributes(node, node.attrib, [])
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'name':
            name_ = child_.text
            name_ = re_.sub(String_cleanup_pat_, " ", name_).strip()
            name_ = self.gds_validate_string(name_, node, 'name')
            self.name = name_
        elif nodeName_ == 'value':
            value_ = child_.text
            value_ = self.gds_validate_string(value_, node, 'value')
            self.value.append(value_)
        elif nodeName_ == 'comment':
            comment_ = child_.text
            comment_ = self.gds_validate_string(comment_, node, 'comment')
            self.comment = comment_
# end class ANDbitwiseAndWithAccumulator


class ASLartihmeticShiftLeft(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, name=None, value=None, comment=None):
        self.name = name
        if value is None:
            self.value = []
        else:
            self.value = value
        self.comment = comment
    def factory(*args_, **kwargs_):
        if ASLartihmeticShiftLeft.subclass:
            return ASLartihmeticShiftLeft.subclass(*args_, **kwargs_)
        else:
            return ASLartihmeticShiftLeft(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_name(self): return self.name
    def set_name(self, name): self.name = name
    def get_value(self): return self.value
    def set_value(self, value): self.value = value
    def add_value(self, value): self.value.append(value)
    def insert_value(self, index, value): self.value[index] = value
    def get_comment(self): return self.comment
    def set_comment(self, comment): self.comment = comment
    def export(self, outfile, level, namespace_='', name_='ASLartihmeticShiftLeft', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = []
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='ASLartihmeticShiftLeft')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_, name_, pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='ASLartihmeticShiftLeft'):
        pass
    def exportChildren(self, outfile, level, namespace_='', name_='ASLartihmeticShiftLeft', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.name is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sname>%s</%sname>%s' % (namespace_, self.gds_format_string(quote_xml(self.name).encode(ExternalEncoding), input_name='name'), namespace_, eol_))
        for value_ in self.value:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%svalue>%s</%svalue>%s' % (namespace_, self.gds_format_string(quote_xml(value_).encode(ExternalEncoding), input_name='value'), namespace_, eol_))
        if self.comment is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%scomment>%s</%scomment>%s' % (namespace_, self.gds_format_string(quote_xml(self.comment).encode(ExternalEncoding), input_name='comment'), namespace_, eol_))
    def hasContent_(self):
        if (
            self.name is not None or
            self.value or
            self.comment is not None
            ):
            return True
        else:
            return False
    def exportLiteral(self, outfile, level, name_='ASLartihmeticShiftLeft'):
        level += 1
        self.exportLiteralAttributes(outfile, level, [], name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        pass
    def exportLiteralChildren(self, outfile, level, name_):
        if self.name is not None:
            showIndent(outfile, level)
            outfile.write('name=%s,\n' % quote_python(self.name).encode(ExternalEncoding))
        showIndent(outfile, level)
        outfile.write('value=[\n')
        level += 1
        for value_ in self.value:
            showIndent(outfile, level)
            outfile.write('%s,\n' % quote_python(value_).encode(ExternalEncoding))
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
        if self.comment is not None:
            showIndent(outfile, level)
            outfile.write('comment=%s,\n' % quote_python(self.comment).encode(ExternalEncoding))
    def build(self, node):
        self.buildAttributes(node, node.attrib, [])
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'name':
            name_ = child_.text
            name_ = re_.sub(String_cleanup_pat_, " ", name_).strip()
            name_ = self.gds_validate_string(name_, node, 'name')
            self.name = name_
        elif nodeName_ == 'value':
            value_ = child_.text
            value_ = self.gds_validate_string(value_, node, 'value')
            self.value.append(value_)
        elif nodeName_ == 'comment':
            comment_ = child_.text
            comment_ = self.gds_validate_string(comment_, node, 'comment')
            self.comment = comment_
# end class ASLartihmeticShiftLeft


class BITtestBits(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, name=None, value=None, comment=None):
        self.name = name
        if value is None:
            self.value = []
        else:
            self.value = value
        self.comment = comment
    def factory(*args_, **kwargs_):
        if BITtestBits.subclass:
            return BITtestBits.subclass(*args_, **kwargs_)
        else:
            return BITtestBits(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_name(self): return self.name
    def set_name(self, name): self.name = name
    def get_value(self): return self.value
    def set_value(self, value): self.value = value
    def add_value(self, value): self.value.append(value)
    def insert_value(self, index, value): self.value[index] = value
    def get_comment(self): return self.comment
    def set_comment(self, comment): self.comment = comment
    def export(self, outfile, level, namespace_='', name_='BITtestBits', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = []
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='BITtestBits')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_, name_, pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='BITtestBits'):
        pass
    def exportChildren(self, outfile, level, namespace_='', name_='BITtestBits', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.name is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sname>%s</%sname>%s' % (namespace_, self.gds_format_string(quote_xml(self.name).encode(ExternalEncoding), input_name='name'), namespace_, eol_))
        for value_ in self.value:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%svalue>%s</%svalue>%s' % (namespace_, self.gds_format_string(quote_xml(value_).encode(ExternalEncoding), input_name='value'), namespace_, eol_))
        if self.comment is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%scomment>%s</%scomment>%s' % (namespace_, self.gds_format_string(quote_xml(self.comment).encode(ExternalEncoding), input_name='comment'), namespace_, eol_))
    def hasContent_(self):
        if (
            self.name is not None or
            self.value or
            self.comment is not None
            ):
            return True
        else:
            return False
    def exportLiteral(self, outfile, level, name_='BITtestBits'):
        level += 1
        self.exportLiteralAttributes(outfile, level, [], name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        pass
    def exportLiteralChildren(self, outfile, level, name_):
        if self.name is not None:
            showIndent(outfile, level)
            outfile.write('name=%s,\n' % quote_python(self.name).encode(ExternalEncoding))
        showIndent(outfile, level)
        outfile.write('value=[\n')
        level += 1
        for value_ in self.value:
            showIndent(outfile, level)
            outfile.write('%s,\n' % quote_python(value_).encode(ExternalEncoding))
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
        if self.comment is not None:
            showIndent(outfile, level)
            outfile.write('comment=%s,\n' % quote_python(self.comment).encode(ExternalEncoding))
    def build(self, node):
        self.buildAttributes(node, node.attrib, [])
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'name':
            name_ = child_.text
            name_ = re_.sub(String_cleanup_pat_, " ", name_).strip()
            name_ = self.gds_validate_string(name_, node, 'name')
            self.name = name_
        elif nodeName_ == 'value':
            value_ = child_.text
            value_ = self.gds_validate_string(value_, node, 'value')
            self.value.append(value_)
        elif nodeName_ == 'comment':
            comment_ = child_.text
            comment_ = self.gds_validate_string(comment_, node, 'comment')
            self.comment = comment_
# end class BITtestBits


class BPLsetCarry(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, name=None, value=None, comment=None):
        self.name = name
        self.value = value
        self.comment = comment
    def factory(*args_, **kwargs_):
        if BPLsetCarry.subclass:
            return BPLsetCarry.subclass(*args_, **kwargs_)
        else:
            return BPLsetCarry(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_name(self): return self.name
    def set_name(self, name): self.name = name
    def get_value(self): return self.value
    def set_value(self, value): self.value = value
    def get_comment(self): return self.comment
    def set_comment(self, comment): self.comment = comment
    def export(self, outfile, level, namespace_='', name_='BPLsetCarry', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = []
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='BPLsetCarry')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_, name_, pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='BPLsetCarry'):
        pass
    def exportChildren(self, outfile, level, namespace_='', name_='BPLsetCarry', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.name is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sname>%s</%sname>%s' % (namespace_, self.gds_format_string(quote_xml(self.name).encode(ExternalEncoding), input_name='name'), namespace_, eol_))
        if self.value is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%svalue>%s</%svalue>%s' % (namespace_, self.gds_format_string(quote_xml(self.value).encode(ExternalEncoding), input_name='value'), namespace_, eol_))
        if self.comment is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%scomment>%s</%scomment>%s' % (namespace_, self.gds_format_string(quote_xml(self.comment).encode(ExternalEncoding), input_name='comment'), namespace_, eol_))
    def hasContent_(self):
        if (
            self.name is not None or
            self.value is not None or
            self.comment is not None
            ):
            return True
        else:
            return False
    def exportLiteral(self, outfile, level, name_='BPLsetCarry'):
        level += 1
        self.exportLiteralAttributes(outfile, level, [], name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        pass
    def exportLiteralChildren(self, outfile, level, name_):
        if self.name is not None:
            showIndent(outfile, level)
            outfile.write('name=%s,\n' % quote_python(self.name).encode(ExternalEncoding))
        if self.value is not None:
            showIndent(outfile, level)
            outfile.write('value=%s,\n' % quote_python(self.value).encode(ExternalEncoding))
        if self.comment is not None:
            showIndent(outfile, level)
            outfile.write('comment=%s,\n' % quote_python(self.comment).encode(ExternalEncoding))
    def build(self, node):
        self.buildAttributes(node, node.attrib, [])
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'name':
            name_ = child_.text
            name_ = re_.sub(String_cleanup_pat_, " ", name_).strip()
            name_ = self.gds_validate_string(name_, node, 'name')
            self.name = name_
        elif nodeName_ == 'value':
            value_ = child_.text
            value_ = self.gds_validate_string(value_, node, 'value')
            self.value = value_
        elif nodeName_ == 'comment':
            comment_ = child_.text
            comment_ = self.gds_validate_string(comment_, node, 'comment')
            self.comment = comment_
# end class BPLsetCarry


class BMIbranchonMinus(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, name=None, value=None, comment=None):
        self.name = name
        self.value = value
        self.comment = comment
    def factory(*args_, **kwargs_):
        if BMIbranchonMinus.subclass:
            return BMIbranchonMinus.subclass(*args_, **kwargs_)
        else:
            return BMIbranchonMinus(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_name(self): return self.name
    def set_name(self, name): self.name = name
    def get_value(self): return self.value
    def set_value(self, value): self.value = value
    def get_comment(self): return self.comment
    def set_comment(self, comment): self.comment = comment
    def export(self, outfile, level, namespace_='', name_='BMIbranchonMinus', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = []
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='BMIbranchonMinus')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_, name_, pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='BMIbranchonMinus'):
        pass
    def exportChildren(self, outfile, level, namespace_='', name_='BMIbranchonMinus', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.name is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sname>%s</%sname>%s' % (namespace_, self.gds_format_string(quote_xml(self.name).encode(ExternalEncoding), input_name='name'), namespace_, eol_))
        if self.value is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%svalue>%s</%svalue>%s' % (namespace_, self.gds_format_string(quote_xml(self.value).encode(ExternalEncoding), input_name='value'), namespace_, eol_))
        if self.comment is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%scomment>%s</%scomment>%s' % (namespace_, self.gds_format_string(quote_xml(self.comment).encode(ExternalEncoding), input_name='comment'), namespace_, eol_))
    def hasContent_(self):
        if (
            self.name is not None or
            self.value is not None or
            self.comment is not None
            ):
            return True
        else:
            return False
    def exportLiteral(self, outfile, level, name_='BMIbranchonMinus'):
        level += 1
        self.exportLiteralAttributes(outfile, level, [], name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        pass
    def exportLiteralChildren(self, outfile, level, name_):
        if self.name is not None:
            showIndent(outfile, level)
            outfile.write('name=%s,\n' % quote_python(self.name).encode(ExternalEncoding))
        if self.value is not None:
            showIndent(outfile, level)
            outfile.write('value=%s,\n' % quote_python(self.value).encode(ExternalEncoding))
        if self.comment is not None:
            showIndent(outfile, level)
            outfile.write('comment=%s,\n' % quote_python(self.comment).encode(ExternalEncoding))
    def build(self, node):
        self.buildAttributes(node, node.attrib, [])
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'name':
            name_ = child_.text
            name_ = re_.sub(String_cleanup_pat_, " ", name_).strip()
            name_ = self.gds_validate_string(name_, node, 'name')
            self.name = name_
        elif nodeName_ == 'value':
            value_ = child_.text
            value_ = self.gds_validate_string(value_, node, 'value')
            self.value = value_
        elif nodeName_ == 'comment':
            comment_ = child_.text
            comment_ = self.gds_validate_string(comment_, node, 'comment')
            self.comment = comment_
# end class BMIbranchonMinus


class BVCbranchonOverflowClear(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, name=None, value=None, comment=None):
        self.name = name
        self.value = value
        self.comment = comment
    def factory(*args_, **kwargs_):
        if BVCbranchonOverflowClear.subclass:
            return BVCbranchonOverflowClear.subclass(*args_, **kwargs_)
        else:
            return BVCbranchonOverflowClear(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_name(self): return self.name
    def set_name(self, name): self.name = name
    def get_value(self): return self.value
    def set_value(self, value): self.value = value
    def get_comment(self): return self.comment
    def set_comment(self, comment): self.comment = comment
    def export(self, outfile, level, namespace_='', name_='BVCbranchonOverflowClear', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = []
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='BVCbranchonOverflowClear')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_, name_, pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='BVCbranchonOverflowClear'):
        pass
    def exportChildren(self, outfile, level, namespace_='', name_='BVCbranchonOverflowClear', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.name is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sname>%s</%sname>%s' % (namespace_, self.gds_format_string(quote_xml(self.name).encode(ExternalEncoding), input_name='name'), namespace_, eol_))
        if self.value is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%svalue>%s</%svalue>%s' % (namespace_, self.gds_format_string(quote_xml(self.value).encode(ExternalEncoding), input_name='value'), namespace_, eol_))
        if self.comment is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%scomment>%s</%scomment>%s' % (namespace_, self.gds_format_string(quote_xml(self.comment).encode(ExternalEncoding), input_name='comment'), namespace_, eol_))
    def hasContent_(self):
        if (
            self.name is not None or
            self.value is not None or
            self.comment is not None
            ):
            return True
        else:
            return False
    def exportLiteral(self, outfile, level, name_='BVCbranchonOverflowClear'):
        level += 1
        self.exportLiteralAttributes(outfile, level, [], name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        pass
    def exportLiteralChildren(self, outfile, level, name_):
        if self.name is not None:
            showIndent(outfile, level)
            outfile.write('name=%s,\n' % quote_python(self.name).encode(ExternalEncoding))
        if self.value is not None:
            showIndent(outfile, level)
            outfile.write('value=%s,\n' % quote_python(self.value).encode(ExternalEncoding))
        if self.comment is not None:
            showIndent(outfile, level)
            outfile.write('comment=%s,\n' % quote_python(self.comment).encode(ExternalEncoding))
    def build(self, node):
        self.buildAttributes(node, node.attrib, [])
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'name':
            name_ = child_.text
            name_ = re_.sub(String_cleanup_pat_, " ", name_).strip()
            name_ = self.gds_validate_string(name_, node, 'name')
            self.name = name_
        elif nodeName_ == 'value':
            value_ = child_.text
            value_ = self.gds_validate_string(value_, node, 'value')
            self.value = value_
        elif nodeName_ == 'comment':
            comment_ = child_.text
            comment_ = self.gds_validate_string(comment_, node, 'comment')
            self.comment = comment_
# end class BVCbranchonOverflowClear


class BVSbranchonOverflowSet(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, name=None, value=None, comment=None):
        self.name = name
        self.value = value
        self.comment = comment
    def factory(*args_, **kwargs_):
        if BVSbranchonOverflowSet.subclass:
            return BVSbranchonOverflowSet.subclass(*args_, **kwargs_)
        else:
            return BVSbranchonOverflowSet(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_name(self): return self.name
    def set_name(self, name): self.name = name
    def get_value(self): return self.value
    def set_value(self, value): self.value = value
    def get_comment(self): return self.comment
    def set_comment(self, comment): self.comment = comment
    def export(self, outfile, level, namespace_='', name_='BVSbranchonOverflowSet', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = []
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='BVSbranchonOverflowSet')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_, name_, pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='BVSbranchonOverflowSet'):
        pass
    def exportChildren(self, outfile, level, namespace_='', name_='BVSbranchonOverflowSet', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.name is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sname>%s</%sname>%s' % (namespace_, self.gds_format_string(quote_xml(self.name).encode(ExternalEncoding), input_name='name'), namespace_, eol_))
        if self.value is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%svalue>%s</%svalue>%s' % (namespace_, self.gds_format_string(quote_xml(self.value).encode(ExternalEncoding), input_name='value'), namespace_, eol_))
        if self.comment is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%scomment>%s</%scomment>%s' % (namespace_, self.gds_format_string(quote_xml(self.comment).encode(ExternalEncoding), input_name='comment'), namespace_, eol_))
    def hasContent_(self):
        if (
            self.name is not None or
            self.value is not None or
            self.comment is not None
            ):
            return True
        else:
            return False
    def exportLiteral(self, outfile, level, name_='BVSbranchonOverflowSet'):
        level += 1
        self.exportLiteralAttributes(outfile, level, [], name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        pass
    def exportLiteralChildren(self, outfile, level, name_):
        if self.name is not None:
            showIndent(outfile, level)
            outfile.write('name=%s,\n' % quote_python(self.name).encode(ExternalEncoding))
        if self.value is not None:
            showIndent(outfile, level)
            outfile.write('value=%s,\n' % quote_python(self.value).encode(ExternalEncoding))
        if self.comment is not None:
            showIndent(outfile, level)
            outfile.write('comment=%s,\n' % quote_python(self.comment).encode(ExternalEncoding))
    def build(self, node):
        self.buildAttributes(node, node.attrib, [])
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'name':
            name_ = child_.text
            name_ = re_.sub(String_cleanup_pat_, " ", name_).strip()
            name_ = self.gds_validate_string(name_, node, 'name')
            self.name = name_
        elif nodeName_ == 'value':
            value_ = child_.text
            value_ = self.gds_validate_string(value_, node, 'value')
            self.value = value_
        elif nodeName_ == 'comment':
            comment_ = child_.text
            comment_ = self.gds_validate_string(comment_, node, 'comment')
            self.comment = comment_
# end class BVSbranchonOverflowSet


class BCCbranchonCarryClear(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, name=None, value=None, comment=None):
        self.name = name
        self.value = value
        self.comment = comment
    def factory(*args_, **kwargs_):
        if BCCbranchonCarryClear.subclass:
            return BCCbranchonCarryClear.subclass(*args_, **kwargs_)
        else:
            return BCCbranchonCarryClear(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_name(self): return self.name
    def set_name(self, name): self.name = name
    def get_value(self): return self.value
    def set_value(self, value): self.value = value
    def get_comment(self): return self.comment
    def set_comment(self, comment): self.comment = comment
    def export(self, outfile, level, namespace_='', name_='BCCbranchonCarryClear', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = []
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='BCCbranchonCarryClear')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_, name_, pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='BCCbranchonCarryClear'):
        pass
    def exportChildren(self, outfile, level, namespace_='', name_='BCCbranchonCarryClear', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.name is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sname>%s</%sname>%s' % (namespace_, self.gds_format_string(quote_xml(self.name).encode(ExternalEncoding), input_name='name'), namespace_, eol_))
        if self.value is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%svalue>%s</%svalue>%s' % (namespace_, self.gds_format_string(quote_xml(self.value).encode(ExternalEncoding), input_name='value'), namespace_, eol_))
        if self.comment is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%scomment>%s</%scomment>%s' % (namespace_, self.gds_format_string(quote_xml(self.comment).encode(ExternalEncoding), input_name='comment'), namespace_, eol_))
    def hasContent_(self):
        if (
            self.name is not None or
            self.value is not None or
            self.comment is not None
            ):
            return True
        else:
            return False
    def exportLiteral(self, outfile, level, name_='BCCbranchonCarryClear'):
        level += 1
        self.exportLiteralAttributes(outfile, level, [], name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        pass
    def exportLiteralChildren(self, outfile, level, name_):
        if self.name is not None:
            showIndent(outfile, level)
            outfile.write('name=%s,\n' % quote_python(self.name).encode(ExternalEncoding))
        if self.value is not None:
            showIndent(outfile, level)
            outfile.write('value=%s,\n' % quote_python(self.value).encode(ExternalEncoding))
        if self.comment is not None:
            showIndent(outfile, level)
            outfile.write('comment=%s,\n' % quote_python(self.comment).encode(ExternalEncoding))
    def build(self, node):
        self.buildAttributes(node, node.attrib, [])
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'name':
            name_ = child_.text
            name_ = re_.sub(String_cleanup_pat_, " ", name_).strip()
            name_ = self.gds_validate_string(name_, node, 'name')
            self.name = name_
        elif nodeName_ == 'value':
            value_ = child_.text
            value_ = self.gds_validate_string(value_, node, 'value')
            self.value = value_
        elif nodeName_ == 'comment':
            comment_ = child_.text
            comment_ = self.gds_validate_string(comment_, node, 'comment')
            self.comment = comment_
# end class BCCbranchonCarryClear


class BCSbranchonCarrySet(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, name=None, value=None, comment=None):
        self.name = name
        self.value = value
        self.comment = comment
    def factory(*args_, **kwargs_):
        if BCSbranchonCarrySet.subclass:
            return BCSbranchonCarrySet.subclass(*args_, **kwargs_)
        else:
            return BCSbranchonCarrySet(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_name(self): return self.name
    def set_name(self, name): self.name = name
    def get_value(self): return self.value
    def set_value(self, value): self.value = value
    def get_comment(self): return self.comment
    def set_comment(self, comment): self.comment = comment
    def export(self, outfile, level, namespace_='', name_='BCSbranchonCarrySet', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = []
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='BCSbranchonCarrySet')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_, name_, pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='BCSbranchonCarrySet'):
        pass
    def exportChildren(self, outfile, level, namespace_='', name_='BCSbranchonCarrySet', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.name is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sname>%s</%sname>%s' % (namespace_, self.gds_format_string(quote_xml(self.name).encode(ExternalEncoding), input_name='name'), namespace_, eol_))
        if self.value is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%svalue>%s</%svalue>%s' % (namespace_, self.gds_format_string(quote_xml(self.value).encode(ExternalEncoding), input_name='value'), namespace_, eol_))
        if self.comment is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%scomment>%s</%scomment>%s' % (namespace_, self.gds_format_string(quote_xml(self.comment).encode(ExternalEncoding), input_name='comment'), namespace_, eol_))
    def hasContent_(self):
        if (
            self.name is not None or
            self.value is not None or
            self.comment is not None
            ):
            return True
        else:
            return False
    def exportLiteral(self, outfile, level, name_='BCSbranchonCarrySet'):
        level += 1
        self.exportLiteralAttributes(outfile, level, [], name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        pass
    def exportLiteralChildren(self, outfile, level, name_):
        if self.name is not None:
            showIndent(outfile, level)
            outfile.write('name=%s,\n' % quote_python(self.name).encode(ExternalEncoding))
        if self.value is not None:
            showIndent(outfile, level)
            outfile.write('value=%s,\n' % quote_python(self.value).encode(ExternalEncoding))
        if self.comment is not None:
            showIndent(outfile, level)
            outfile.write('comment=%s,\n' % quote_python(self.comment).encode(ExternalEncoding))
    def build(self, node):
        self.buildAttributes(node, node.attrib, [])
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'name':
            name_ = child_.text
            name_ = re_.sub(String_cleanup_pat_, " ", name_).strip()
            name_ = self.gds_validate_string(name_, node, 'name')
            self.name = name_
        elif nodeName_ == 'value':
            value_ = child_.text
            value_ = self.gds_validate_string(value_, node, 'value')
            self.value = value_
        elif nodeName_ == 'comment':
            comment_ = child_.text
            comment_ = self.gds_validate_string(comment_, node, 'comment')
            self.comment = comment_
# end class BCSbranchonCarrySet


class BEQbranchonEqual(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, name=None, value=None, comment=None):
        self.name = name
        self.value = value
        self.comment = comment
    def factory(*args_, **kwargs_):
        if BEQbranchonEqual.subclass:
            return BEQbranchonEqual.subclass(*args_, **kwargs_)
        else:
            return BEQbranchonEqual(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_name(self): return self.name
    def set_name(self, name): self.name = name
    def get_value(self): return self.value
    def set_value(self, value): self.value = value
    def get_comment(self): return self.comment
    def set_comment(self, comment): self.comment = comment
    def export(self, outfile, level, namespace_='', name_='BEQbranchonEqual', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = []
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='BEQbranchonEqual')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_, name_, pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='BEQbranchonEqual'):
        pass
    def exportChildren(self, outfile, level, namespace_='', name_='BEQbranchonEqual', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.name is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sname>%s</%sname>%s' % (namespace_, self.gds_format_string(quote_xml(self.name).encode(ExternalEncoding), input_name='name'), namespace_, eol_))
        if self.value is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%svalue>%s</%svalue>%s' % (namespace_, self.gds_format_string(quote_xml(self.value).encode(ExternalEncoding), input_name='value'), namespace_, eol_))
        if self.comment is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%scomment>%s</%scomment>%s' % (namespace_, self.gds_format_string(quote_xml(self.comment).encode(ExternalEncoding), input_name='comment'), namespace_, eol_))
    def hasContent_(self):
        if (
            self.name is not None or
            self.value is not None or
            self.comment is not None
            ):
            return True
        else:
            return False
    def exportLiteral(self, outfile, level, name_='BEQbranchonEqual'):
        level += 1
        self.exportLiteralAttributes(outfile, level, [], name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        pass
    def exportLiteralChildren(self, outfile, level, name_):
        if self.name is not None:
            showIndent(outfile, level)
            outfile.write('name=%s,\n' % quote_python(self.name).encode(ExternalEncoding))
        if self.value is not None:
            showIndent(outfile, level)
            outfile.write('value=%s,\n' % quote_python(self.value).encode(ExternalEncoding))
        if self.comment is not None:
            showIndent(outfile, level)
            outfile.write('comment=%s,\n' % quote_python(self.comment).encode(ExternalEncoding))
    def build(self, node):
        self.buildAttributes(node, node.attrib, [])
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'name':
            name_ = child_.text
            name_ = re_.sub(String_cleanup_pat_, " ", name_).strip()
            name_ = self.gds_validate_string(name_, node, 'name')
            self.name = name_
        elif nodeName_ == 'value':
            value_ = child_.text
            value_ = self.gds_validate_string(value_, node, 'value')
            self.value = value_
        elif nodeName_ == 'comment':
            comment_ = child_.text
            comment_ = self.gds_validate_string(comment_, node, 'comment')
            self.comment = comment_
# end class BEQbranchonEqual


class BNEbranchonNotequal(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, name=None, value=None, comment=None):
        self.name = name
        self.value = value
        self.comment = comment
    def factory(*args_, **kwargs_):
        if BNEbranchonNotequal.subclass:
            return BNEbranchonNotequal.subclass(*args_, **kwargs_)
        else:
            return BNEbranchonNotequal(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_name(self): return self.name
    def set_name(self, name): self.name = name
    def get_value(self): return self.value
    def set_value(self, value): self.value = value
    def get_comment(self): return self.comment
    def set_comment(self, comment): self.comment = comment
    def export(self, outfile, level, namespace_='', name_='BNEbranchonNotequal', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = []
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='BNEbranchonNotequal')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_, name_, pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='BNEbranchonNotequal'):
        pass
    def exportChildren(self, outfile, level, namespace_='', name_='BNEbranchonNotequal', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.name is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sname>%s</%sname>%s' % (namespace_, self.gds_format_string(quote_xml(self.name).encode(ExternalEncoding), input_name='name'), namespace_, eol_))
        if self.value is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%svalue>%s</%svalue>%s' % (namespace_, self.gds_format_string(quote_xml(self.value).encode(ExternalEncoding), input_name='value'), namespace_, eol_))
        if self.comment is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%scomment>%s</%scomment>%s' % (namespace_, self.gds_format_string(quote_xml(self.comment).encode(ExternalEncoding), input_name='comment'), namespace_, eol_))
    def hasContent_(self):
        if (
            self.name is not None or
            self.value is not None or
            self.comment is not None
            ):
            return True
        else:
            return False
    def exportLiteral(self, outfile, level, name_='BNEbranchonNotequal'):
        level += 1
        self.exportLiteralAttributes(outfile, level, [], name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        pass
    def exportLiteralChildren(self, outfile, level, name_):
        if self.name is not None:
            showIndent(outfile, level)
            outfile.write('name=%s,\n' % quote_python(self.name).encode(ExternalEncoding))
        if self.value is not None:
            showIndent(outfile, level)
            outfile.write('value=%s,\n' % quote_python(self.value).encode(ExternalEncoding))
        if self.comment is not None:
            showIndent(outfile, level)
            outfile.write('comment=%s,\n' % quote_python(self.comment).encode(ExternalEncoding))
    def build(self, node):
        self.buildAttributes(node, node.attrib, [])
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'name':
            name_ = child_.text
            name_ = re_.sub(String_cleanup_pat_, " ", name_).strip()
            name_ = self.gds_validate_string(name_, node, 'name')
            self.name = name_
        elif nodeName_ == 'value':
            value_ = child_.text
            value_ = self.gds_validate_string(value_, node, 'value')
            self.value = value_
        elif nodeName_ == 'comment':
            comment_ = child_.text
            comment_ = self.gds_validate_string(comment_, node, 'comment')
            self.comment = comment_
# end class BNEbranchonNotequal


class BRKbreak(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, name=None, value=None, comment=None):
        self.name = name
        if value is None:
            self.value = []
        else:
            self.value = value
        self.comment = comment
    def factory(*args_, **kwargs_):
        if BRKbreak.subclass:
            return BRKbreak.subclass(*args_, **kwargs_)
        else:
            return BRKbreak(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_name(self): return self.name
    def set_name(self, name): self.name = name
    def get_value(self): return self.value
    def set_value(self, value): self.value = value
    def add_value(self, value): self.value.append(value)
    def insert_value(self, index, value): self.value[index] = value
    def get_comment(self): return self.comment
    def set_comment(self, comment): self.comment = comment
    def export(self, outfile, level, namespace_='', name_='BRKbreak', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = []
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='BRKbreak')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_, name_, pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='BRKbreak'):
        pass
    def exportChildren(self, outfile, level, namespace_='', name_='BRKbreak', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.name is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sname>%s</%sname>%s' % (namespace_, self.gds_format_string(quote_xml(self.name).encode(ExternalEncoding), input_name='name'), namespace_, eol_))
        for value_ in self.value:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%svalue>%s</%svalue>%s' % (namespace_, self.gds_format_string(quote_xml(value_).encode(ExternalEncoding), input_name='value'), namespace_, eol_))
        if self.comment is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%scomment>%s</%scomment>%s' % (namespace_, self.gds_format_string(quote_xml(self.comment).encode(ExternalEncoding), input_name='comment'), namespace_, eol_))
    def hasContent_(self):
        if (
            self.name is not None or
            self.value or
            self.comment is not None
            ):
            return True
        else:
            return False
    def exportLiteral(self, outfile, level, name_='BRKbreak'):
        level += 1
        self.exportLiteralAttributes(outfile, level, [], name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        pass
    def exportLiteralChildren(self, outfile, level, name_):
        if self.name is not None:
            showIndent(outfile, level)
            outfile.write('name=%s,\n' % quote_python(self.name).encode(ExternalEncoding))
        showIndent(outfile, level)
        outfile.write('value=[\n')
        level += 1
        for value_ in self.value:
            showIndent(outfile, level)
            outfile.write('%s,\n' % quote_python(value_).encode(ExternalEncoding))
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
        if self.comment is not None:
            showIndent(outfile, level)
            outfile.write('comment=%s,\n' % quote_python(self.comment).encode(ExternalEncoding))
    def build(self, node):
        self.buildAttributes(node, node.attrib, [])
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'name':
            name_ = child_.text
            name_ = re_.sub(String_cleanup_pat_, " ", name_).strip()
            name_ = self.gds_validate_string(name_, node, 'name')
            self.name = name_
        elif nodeName_ == 'value':
            value_ = child_.text
            value_ = self.gds_validate_string(value_, node, 'value')
            self.value.append(value_)
        elif nodeName_ == 'comment':
            comment_ = child_.text
            comment_ = self.gds_validate_string(comment_, node, 'comment')
            self.comment = comment_
# end class BRKbreak


class CMPcompareAccumulator(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, name=None, value=None, comment=None):
        self.name = name
        if value is None:
            self.value = []
        else:
            self.value = value
        self.comment = comment
    def factory(*args_, **kwargs_):
        if CMPcompareAccumulator.subclass:
            return CMPcompareAccumulator.subclass(*args_, **kwargs_)
        else:
            return CMPcompareAccumulator(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_name(self): return self.name
    def set_name(self, name): self.name = name
    def get_value(self): return self.value
    def set_value(self, value): self.value = value
    def add_value(self, value): self.value.append(value)
    def insert_value(self, index, value): self.value[index] = value
    def get_comment(self): return self.comment
    def set_comment(self, comment): self.comment = comment
    def export(self, outfile, level, namespace_='', name_='CMPcompareAccumulator', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = []
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='CMPcompareAccumulator')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_, name_, pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='CMPcompareAccumulator'):
        pass
    def exportChildren(self, outfile, level, namespace_='', name_='CMPcompareAccumulator', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.name is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sname>%s</%sname>%s' % (namespace_, self.gds_format_string(quote_xml(self.name).encode(ExternalEncoding), input_name='name'), namespace_, eol_))
        for value_ in self.value:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%svalue>%s</%svalue>%s' % (namespace_, self.gds_format_string(quote_xml(value_).encode(ExternalEncoding), input_name='value'), namespace_, eol_))
        if self.comment is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%scomment>%s</%scomment>%s' % (namespace_, self.gds_format_string(quote_xml(self.comment).encode(ExternalEncoding), input_name='comment'), namespace_, eol_))
    def hasContent_(self):
        if (
            self.name is not None or
            self.value or
            self.comment is not None
            ):
            return True
        else:
            return False
    def exportLiteral(self, outfile, level, name_='CMPcompareAccumulator'):
        level += 1
        self.exportLiteralAttributes(outfile, level, [], name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        pass
    def exportLiteralChildren(self, outfile, level, name_):
        if self.name is not None:
            showIndent(outfile, level)
            outfile.write('name=%s,\n' % quote_python(self.name).encode(ExternalEncoding))
        showIndent(outfile, level)
        outfile.write('value=[\n')
        level += 1
        for value_ in self.value:
            showIndent(outfile, level)
            outfile.write('%s,\n' % quote_python(value_).encode(ExternalEncoding))
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
        if self.comment is not None:
            showIndent(outfile, level)
            outfile.write('comment=%s,\n' % quote_python(self.comment).encode(ExternalEncoding))
    def build(self, node):
        self.buildAttributes(node, node.attrib, [])
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'name':
            name_ = child_.text
            name_ = re_.sub(String_cleanup_pat_, " ", name_).strip()
            name_ = self.gds_validate_string(name_, node, 'name')
            self.name = name_
        elif nodeName_ == 'value':
            value_ = child_.text
            value_ = self.gds_validate_string(value_, node, 'value')
            self.value.append(value_)
        elif nodeName_ == 'comment':
            comment_ = child_.text
            comment_ = self.gds_validate_string(comment_, node, 'comment')
            self.comment = comment_
# end class CMPcompareAccumulator


class CPXcompareXRegister(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, name=None, value=None, comment=None):
        self.name = name
        if value is None:
            self.value = []
        else:
            self.value = value
        self.comment = comment
    def factory(*args_, **kwargs_):
        if CPXcompareXRegister.subclass:
            return CPXcompareXRegister.subclass(*args_, **kwargs_)
        else:
            return CPXcompareXRegister(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_name(self): return self.name
    def set_name(self, name): self.name = name
    def get_value(self): return self.value
    def set_value(self, value): self.value = value
    def add_value(self, value): self.value.append(value)
    def insert_value(self, index, value): self.value[index] = value
    def get_comment(self): return self.comment
    def set_comment(self, comment): self.comment = comment
    def export(self, outfile, level, namespace_='', name_='CPXcompareXRegister', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = []
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='CPXcompareXRegister')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_, name_, pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='CPXcompareXRegister'):
        pass
    def exportChildren(self, outfile, level, namespace_='', name_='CPXcompareXRegister', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.name is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sname>%s</%sname>%s' % (namespace_, self.gds_format_string(quote_xml(self.name).encode(ExternalEncoding), input_name='name'), namespace_, eol_))
        for value_ in self.value:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%svalue>%s</%svalue>%s' % (namespace_, self.gds_format_string(quote_xml(value_).encode(ExternalEncoding), input_name='value'), namespace_, eol_))
        if self.comment is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%scomment>%s</%scomment>%s' % (namespace_, self.gds_format_string(quote_xml(self.comment).encode(ExternalEncoding), input_name='comment'), namespace_, eol_))
    def hasContent_(self):
        if (
            self.name is not None or
            self.value or
            self.comment is not None
            ):
            return True
        else:
            return False
    def exportLiteral(self, outfile, level, name_='CPXcompareXRegister'):
        level += 1
        self.exportLiteralAttributes(outfile, level, [], name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        pass
    def exportLiteralChildren(self, outfile, level, name_):
        if self.name is not None:
            showIndent(outfile, level)
            outfile.write('name=%s,\n' % quote_python(self.name).encode(ExternalEncoding))
        showIndent(outfile, level)
        outfile.write('value=[\n')
        level += 1
        for value_ in self.value:
            showIndent(outfile, level)
            outfile.write('%s,\n' % quote_python(value_).encode(ExternalEncoding))
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
        if self.comment is not None:
            showIndent(outfile, level)
            outfile.write('comment=%s,\n' % quote_python(self.comment).encode(ExternalEncoding))
    def build(self, node):
        self.buildAttributes(node, node.attrib, [])
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'name':
            name_ = child_.text
            name_ = re_.sub(String_cleanup_pat_, " ", name_).strip()
            name_ = self.gds_validate_string(name_, node, 'name')
            self.name = name_
        elif nodeName_ == 'value':
            value_ = child_.text
            value_ = self.gds_validate_string(value_, node, 'value')
            self.value.append(value_)
        elif nodeName_ == 'comment':
            comment_ = child_.text
            comment_ = self.gds_validate_string(comment_, node, 'comment')
            self.comment = comment_
# end class CPXcompareXRegister


class CPYcompareYRegister(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, name=None, value=None, comment=None):
        self.name = name
        if value is None:
            self.value = []
        else:
            self.value = value
        self.comment = comment
    def factory(*args_, **kwargs_):
        if CPYcompareYRegister.subclass:
            return CPYcompareYRegister.subclass(*args_, **kwargs_)
        else:
            return CPYcompareYRegister(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_name(self): return self.name
    def set_name(self, name): self.name = name
    def get_value(self): return self.value
    def set_value(self, value): self.value = value
    def add_value(self, value): self.value.append(value)
    def insert_value(self, index, value): self.value[index] = value
    def get_comment(self): return self.comment
    def set_comment(self, comment): self.comment = comment
    def export(self, outfile, level, namespace_='', name_='CPYcompareYRegister', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = []
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='CPYcompareYRegister')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_, name_, pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='CPYcompareYRegister'):
        pass
    def exportChildren(self, outfile, level, namespace_='', name_='CPYcompareYRegister', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.name is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sname>%s</%sname>%s' % (namespace_, self.gds_format_string(quote_xml(self.name).encode(ExternalEncoding), input_name='name'), namespace_, eol_))
        for value_ in self.value:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%svalue>%s</%svalue>%s' % (namespace_, self.gds_format_string(quote_xml(value_).encode(ExternalEncoding), input_name='value'), namespace_, eol_))
        if self.comment is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%scomment>%s</%scomment>%s' % (namespace_, self.gds_format_string(quote_xml(self.comment).encode(ExternalEncoding), input_name='comment'), namespace_, eol_))
    def hasContent_(self):
        if (
            self.name is not None or
            self.value or
            self.comment is not None
            ):
            return True
        else:
            return False
    def exportLiteral(self, outfile, level, name_='CPYcompareYRegister'):
        level += 1
        self.exportLiteralAttributes(outfile, level, [], name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        pass
    def exportLiteralChildren(self, outfile, level, name_):
        if self.name is not None:
            showIndent(outfile, level)
            outfile.write('name=%s,\n' % quote_python(self.name).encode(ExternalEncoding))
        showIndent(outfile, level)
        outfile.write('value=[\n')
        level += 1
        for value_ in self.value:
            showIndent(outfile, level)
            outfile.write('%s,\n' % quote_python(value_).encode(ExternalEncoding))
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
        if self.comment is not None:
            showIndent(outfile, level)
            outfile.write('comment=%s,\n' % quote_python(self.comment).encode(ExternalEncoding))
    def build(self, node):
        self.buildAttributes(node, node.attrib, [])
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'name':
            name_ = child_.text
            name_ = re_.sub(String_cleanup_pat_, " ", name_).strip()
            name_ = self.gds_validate_string(name_, node, 'name')
            self.name = name_
        elif nodeName_ == 'value':
            value_ = child_.text
            value_ = self.gds_validate_string(value_, node, 'value')
            self.value.append(value_)
        elif nodeName_ == 'comment':
            comment_ = child_.text
            comment_ = self.gds_validate_string(comment_, node, 'comment')
            self.comment = comment_
# end class CPYcompareYRegister


class DECdecrementMemory(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, name=None, value=None, comment=None):
        self.name = name
        if value is None:
            self.value = []
        else:
            self.value = value
        self.comment = comment
    def factory(*args_, **kwargs_):
        if DECdecrementMemory.subclass:
            return DECdecrementMemory.subclass(*args_, **kwargs_)
        else:
            return DECdecrementMemory(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_name(self): return self.name
    def set_name(self, name): self.name = name
    def get_value(self): return self.value
    def set_value(self, value): self.value = value
    def add_value(self, value): self.value.append(value)
    def insert_value(self, index, value): self.value[index] = value
    def get_comment(self): return self.comment
    def set_comment(self, comment): self.comment = comment
    def export(self, outfile, level, namespace_='', name_='DECdecrementMemory', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = []
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='DECdecrementMemory')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_, name_, pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='DECdecrementMemory'):
        pass
    def exportChildren(self, outfile, level, namespace_='', name_='DECdecrementMemory', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.name is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sname>%s</%sname>%s' % (namespace_, self.gds_format_string(quote_xml(self.name).encode(ExternalEncoding), input_name='name'), namespace_, eol_))
        for value_ in self.value:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%svalue>%s</%svalue>%s' % (namespace_, self.gds_format_string(quote_xml(value_).encode(ExternalEncoding), input_name='value'), namespace_, eol_))
        if self.comment is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%scomment>%s</%scomment>%s' % (namespace_, self.gds_format_string(quote_xml(self.comment).encode(ExternalEncoding), input_name='comment'), namespace_, eol_))
    def hasContent_(self):
        if (
            self.name is not None or
            self.value or
            self.comment is not None
            ):
            return True
        else:
            return False
    def exportLiteral(self, outfile, level, name_='DECdecrementMemory'):
        level += 1
        self.exportLiteralAttributes(outfile, level, [], name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        pass
    def exportLiteralChildren(self, outfile, level, name_):
        if self.name is not None:
            showIndent(outfile, level)
            outfile.write('name=%s,\n' % quote_python(self.name).encode(ExternalEncoding))
        showIndent(outfile, level)
        outfile.write('value=[\n')
        level += 1
        for value_ in self.value:
            showIndent(outfile, level)
            outfile.write('%s,\n' % quote_python(value_).encode(ExternalEncoding))
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
        if self.comment is not None:
            showIndent(outfile, level)
            outfile.write('comment=%s,\n' % quote_python(self.comment).encode(ExternalEncoding))
    def build(self, node):
        self.buildAttributes(node, node.attrib, [])
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'name':
            name_ = child_.text
            name_ = re_.sub(String_cleanup_pat_, " ", name_).strip()
            name_ = self.gds_validate_string(name_, node, 'name')
            self.name = name_
        elif nodeName_ == 'value':
            value_ = child_.text
            value_ = self.gds_validate_string(value_, node, 'value')
            self.value.append(value_)
        elif nodeName_ == 'comment':
            comment_ = child_.text
            comment_ = self.gds_validate_string(comment_, node, 'comment')
            self.comment = comment_
# end class DECdecrementMemory


class EORbitWiseExclusiveOr(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, name=None, value=None, comment=None):
        self.name = name
        if value is None:
            self.value = []
        else:
            self.value = value
        self.comment = comment
    def factory(*args_, **kwargs_):
        if EORbitWiseExclusiveOr.subclass:
            return EORbitWiseExclusiveOr.subclass(*args_, **kwargs_)
        else:
            return EORbitWiseExclusiveOr(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_name(self): return self.name
    def set_name(self, name): self.name = name
    def get_value(self): return self.value
    def set_value(self, value): self.value = value
    def add_value(self, value): self.value.append(value)
    def insert_value(self, index, value): self.value[index] = value
    def get_comment(self): return self.comment
    def set_comment(self, comment): self.comment = comment
    def export(self, outfile, level, namespace_='', name_='EORbitWiseExclusiveOr', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = []
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='EORbitWiseExclusiveOr')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_, name_, pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='EORbitWiseExclusiveOr'):
        pass
    def exportChildren(self, outfile, level, namespace_='', name_='EORbitWiseExclusiveOr', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.name is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sname>%s</%sname>%s' % (namespace_, self.gds_format_string(quote_xml(self.name).encode(ExternalEncoding), input_name='name'), namespace_, eol_))
        for value_ in self.value:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%svalue>%s</%svalue>%s' % (namespace_, self.gds_format_string(quote_xml(value_).encode(ExternalEncoding), input_name='value'), namespace_, eol_))
        if self.comment is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%scomment>%s</%scomment>%s' % (namespace_, self.gds_format_string(quote_xml(self.comment).encode(ExternalEncoding), input_name='comment'), namespace_, eol_))
    def hasContent_(self):
        if (
            self.name is not None or
            self.value or
            self.comment is not None
            ):
            return True
        else:
            return False
    def exportLiteral(self, outfile, level, name_='EORbitWiseExclusiveOr'):
        level += 1
        self.exportLiteralAttributes(outfile, level, [], name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        pass
    def exportLiteralChildren(self, outfile, level, name_):
        if self.name is not None:
            showIndent(outfile, level)
            outfile.write('name=%s,\n' % quote_python(self.name).encode(ExternalEncoding))
        showIndent(outfile, level)
        outfile.write('value=[\n')
        level += 1
        for value_ in self.value:
            showIndent(outfile, level)
            outfile.write('%s,\n' % quote_python(value_).encode(ExternalEncoding))
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
        if self.comment is not None:
            showIndent(outfile, level)
            outfile.write('comment=%s,\n' % quote_python(self.comment).encode(ExternalEncoding))
    def build(self, node):
        self.buildAttributes(node, node.attrib, [])
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'name':
            name_ = child_.text
            name_ = re_.sub(String_cleanup_pat_, " ", name_).strip()
            name_ = self.gds_validate_string(name_, node, 'name')
            self.name = name_
        elif nodeName_ == 'value':
            value_ = child_.text
            value_ = self.gds_validate_string(value_, node, 'value')
            self.value.append(value_)
        elif nodeName_ == 'comment':
            comment_ = child_.text
            comment_ = self.gds_validate_string(comment_, node, 'comment')
            self.comment = comment_
# end class EORbitWiseExclusiveOr


class CLClearCarry(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, name=None, value=None, comment=None):
        self.name = name
        self.value = value
        self.comment = comment
    def factory(*args_, **kwargs_):
        if CLClearCarry.subclass:
            return CLClearCarry.subclass(*args_, **kwargs_)
        else:
            return CLClearCarry(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_name(self): return self.name
    def set_name(self, name): self.name = name
    def get_value(self): return self.value
    def set_value(self, value): self.value = value
    def get_comment(self): return self.comment
    def set_comment(self, comment): self.comment = comment
    def export(self, outfile, level, namespace_='', name_='CLClearCarry', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = []
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='CLClearCarry')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_, name_, pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='CLClearCarry'):
        pass
    def exportChildren(self, outfile, level, namespace_='', name_='CLClearCarry', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.name is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sname>%s</%sname>%s' % (namespace_, self.gds_format_string(quote_xml(self.name).encode(ExternalEncoding), input_name='name'), namespace_, eol_))
        if self.value is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%svalue>%s</%svalue>%s' % (namespace_, self.gds_format_string(quote_xml(self.value).encode(ExternalEncoding), input_name='value'), namespace_, eol_))
        if self.comment is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%scomment>%s</%scomment>%s' % (namespace_, self.gds_format_string(quote_xml(self.comment).encode(ExternalEncoding), input_name='comment'), namespace_, eol_))
    def hasContent_(self):
        if (
            self.name is not None or
            self.value is not None or
            self.comment is not None
            ):
            return True
        else:
            return False
    def exportLiteral(self, outfile, level, name_='CLClearCarry'):
        level += 1
        self.exportLiteralAttributes(outfile, level, [], name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        pass
    def exportLiteralChildren(self, outfile, level, name_):
        if self.name is not None:
            showIndent(outfile, level)
            outfile.write('name=%s,\n' % quote_python(self.name).encode(ExternalEncoding))
        if self.value is not None:
            showIndent(outfile, level)
            outfile.write('value=%s,\n' % quote_python(self.value).encode(ExternalEncoding))
        if self.comment is not None:
            showIndent(outfile, level)
            outfile.write('comment=%s,\n' % quote_python(self.comment).encode(ExternalEncoding))
    def build(self, node):
        self.buildAttributes(node, node.attrib, [])
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'name':
            name_ = child_.text
            name_ = re_.sub(String_cleanup_pat_, " ", name_).strip()
            name_ = self.gds_validate_string(name_, node, 'name')
            self.name = name_
        elif nodeName_ == 'value':
            value_ = child_.text
            value_ = self.gds_validate_string(value_, node, 'value')
            self.value = value_
        elif nodeName_ == 'comment':
            comment_ = child_.text
            comment_ = self.gds_validate_string(comment_, node, 'comment')
            self.comment = comment_
# end class CLClearCarry


class SECsetCarry(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, name=None, value=None, comment=None):
        self.name = name
        self.value = value
        self.comment = comment
    def factory(*args_, **kwargs_):
        if SECsetCarry.subclass:
            return SECsetCarry.subclass(*args_, **kwargs_)
        else:
            return SECsetCarry(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_name(self): return self.name
    def set_name(self, name): self.name = name
    def get_value(self): return self.value
    def set_value(self, value): self.value = value
    def get_comment(self): return self.comment
    def set_comment(self, comment): self.comment = comment
    def export(self, outfile, level, namespace_='', name_='SECsetCarry', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = []
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='SECsetCarry')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_, name_, pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='SECsetCarry'):
        pass
    def exportChildren(self, outfile, level, namespace_='', name_='SECsetCarry', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.name is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sname>%s</%sname>%s' % (namespace_, self.gds_format_string(quote_xml(self.name).encode(ExternalEncoding), input_name='name'), namespace_, eol_))
        if self.value is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%svalue>%s</%svalue>%s' % (namespace_, self.gds_format_string(quote_xml(self.value).encode(ExternalEncoding), input_name='value'), namespace_, eol_))
        if self.comment is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%scomment>%s</%scomment>%s' % (namespace_, self.gds_format_string(quote_xml(self.comment).encode(ExternalEncoding), input_name='comment'), namespace_, eol_))
    def hasContent_(self):
        if (
            self.name is not None or
            self.value is not None or
            self.comment is not None
            ):
            return True
        else:
            return False
    def exportLiteral(self, outfile, level, name_='SECsetCarry'):
        level += 1
        self.exportLiteralAttributes(outfile, level, [], name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        pass
    def exportLiteralChildren(self, outfile, level, name_):
        if self.name is not None:
            showIndent(outfile, level)
            outfile.write('name=%s,\n' % quote_python(self.name).encode(ExternalEncoding))
        if self.value is not None:
            showIndent(outfile, level)
            outfile.write('value=%s,\n' % quote_python(self.value).encode(ExternalEncoding))
        if self.comment is not None:
            showIndent(outfile, level)
            outfile.write('comment=%s,\n' % quote_python(self.comment).encode(ExternalEncoding))
    def build(self, node):
        self.buildAttributes(node, node.attrib, [])
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'name':
            name_ = child_.text
            name_ = re_.sub(String_cleanup_pat_, " ", name_).strip()
            name_ = self.gds_validate_string(name_, node, 'name')
            self.name = name_
        elif nodeName_ == 'value':
            value_ = child_.text
            value_ = self.gds_validate_string(value_, node, 'value')
            self.value = value_
        elif nodeName_ == 'comment':
            comment_ = child_.text
            comment_ = self.gds_validate_string(comment_, node, 'comment')
            self.comment = comment_
# end class SECsetCarry


class SEIsetCarry(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, name=None, value=None, comment=None):
        self.name = name
        self.value = value
        self.comment = comment
    def factory(*args_, **kwargs_):
        if SEIsetCarry.subclass:
            return SEIsetCarry.subclass(*args_, **kwargs_)
        else:
            return SEIsetCarry(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_name(self): return self.name
    def set_name(self, name): self.name = name
    def get_value(self): return self.value
    def set_value(self, value): self.value = value
    def get_comment(self): return self.comment
    def set_comment(self, comment): self.comment = comment
    def export(self, outfile, level, namespace_='', name_='SEIsetCarry', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = []
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='SEIsetCarry')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_, name_, pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='SEIsetCarry'):
        pass
    def exportChildren(self, outfile, level, namespace_='', name_='SEIsetCarry', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.name is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sname>%s</%sname>%s' % (namespace_, self.gds_format_string(quote_xml(self.name).encode(ExternalEncoding), input_name='name'), namespace_, eol_))
        if self.value is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%svalue>%s</%svalue>%s' % (namespace_, self.gds_format_string(quote_xml(self.value).encode(ExternalEncoding), input_name='value'), namespace_, eol_))
        if self.comment is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%scomment>%s</%scomment>%s' % (namespace_, self.gds_format_string(quote_xml(self.comment).encode(ExternalEncoding), input_name='comment'), namespace_, eol_))
    def hasContent_(self):
        if (
            self.name is not None or
            self.value is not None or
            self.comment is not None
            ):
            return True
        else:
            return False
    def exportLiteral(self, outfile, level, name_='SEIsetCarry'):
        level += 1
        self.exportLiteralAttributes(outfile, level, [], name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        pass
    def exportLiteralChildren(self, outfile, level, name_):
        if self.name is not None:
            showIndent(outfile, level)
            outfile.write('name=%s,\n' % quote_python(self.name).encode(ExternalEncoding))
        if self.value is not None:
            showIndent(outfile, level)
            outfile.write('value=%s,\n' % quote_python(self.value).encode(ExternalEncoding))
        if self.comment is not None:
            showIndent(outfile, level)
            outfile.write('comment=%s,\n' % quote_python(self.comment).encode(ExternalEncoding))
    def build(self, node):
        self.buildAttributes(node, node.attrib, [])
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'name':
            name_ = child_.text
            name_ = re_.sub(String_cleanup_pat_, " ", name_).strip()
            name_ = self.gds_validate_string(name_, node, 'name')
            self.name = name_
        elif nodeName_ == 'value':
            value_ = child_.text
            value_ = self.gds_validate_string(value_, node, 'value')
            self.value = value_
        elif nodeName_ == 'comment':
            comment_ = child_.text
            comment_ = self.gds_validate_string(comment_, node, 'comment')
            self.comment = comment_
# end class SEIsetCarry


class CLIclearInterrupt(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, name=None, value=None, comment=None):
        self.name = name
        self.value = value
        self.comment = comment
    def factory(*args_, **kwargs_):
        if CLIclearInterrupt.subclass:
            return CLIclearInterrupt.subclass(*args_, **kwargs_)
        else:
            return CLIclearInterrupt(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_name(self): return self.name
    def set_name(self, name): self.name = name
    def get_value(self): return self.value
    def set_value(self, value): self.value = value
    def get_comment(self): return self.comment
    def set_comment(self, comment): self.comment = comment
    def export(self, outfile, level, namespace_='', name_='CLIclearInterrupt', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = []
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='CLIclearInterrupt')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_, name_, pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='CLIclearInterrupt'):
        pass
    def exportChildren(self, outfile, level, namespace_='', name_='CLIclearInterrupt', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.name is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sname>%s</%sname>%s' % (namespace_, self.gds_format_string(quote_xml(self.name).encode(ExternalEncoding), input_name='name'), namespace_, eol_))
        if self.value is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%svalue>%s</%svalue>%s' % (namespace_, self.gds_format_string(quote_xml(self.value).encode(ExternalEncoding), input_name='value'), namespace_, eol_))
        if self.comment is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%scomment>%s</%scomment>%s' % (namespace_, self.gds_format_string(quote_xml(self.comment).encode(ExternalEncoding), input_name='comment'), namespace_, eol_))
    def hasContent_(self):
        if (
            self.name is not None or
            self.value is not None or
            self.comment is not None
            ):
            return True
        else:
            return False
    def exportLiteral(self, outfile, level, name_='CLIclearInterrupt'):
        level += 1
        self.exportLiteralAttributes(outfile, level, [], name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        pass
    def exportLiteralChildren(self, outfile, level, name_):
        if self.name is not None:
            showIndent(outfile, level)
            outfile.write('name=%s,\n' % quote_python(self.name).encode(ExternalEncoding))
        if self.value is not None:
            showIndent(outfile, level)
            outfile.write('value=%s,\n' % quote_python(self.value).encode(ExternalEncoding))
        if self.comment is not None:
            showIndent(outfile, level)
            outfile.write('comment=%s,\n' % quote_python(self.comment).encode(ExternalEncoding))
    def build(self, node):
        self.buildAttributes(node, node.attrib, [])
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'name':
            name_ = child_.text
            name_ = re_.sub(String_cleanup_pat_, " ", name_).strip()
            name_ = self.gds_validate_string(name_, node, 'name')
            self.name = name_
        elif nodeName_ == 'value':
            value_ = child_.text
            value_ = self.gds_validate_string(value_, node, 'value')
            self.value = value_
        elif nodeName_ == 'comment':
            comment_ = child_.text
            comment_ = self.gds_validate_string(comment_, node, 'comment')
            self.comment = comment_
# end class CLIclearInterrupt


class SEIsetInterrupt(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, name=None, value=None, comment=None):
        self.name = name
        self.value = value
        self.comment = comment
    def factory(*args_, **kwargs_):
        if SEIsetInterrupt.subclass:
            return SEIsetInterrupt.subclass(*args_, **kwargs_)
        else:
            return SEIsetInterrupt(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_name(self): return self.name
    def set_name(self, name): self.name = name
    def get_value(self): return self.value
    def set_value(self, value): self.value = value
    def get_comment(self): return self.comment
    def set_comment(self, comment): self.comment = comment
    def export(self, outfile, level, namespace_='', name_='SEIsetInterrupt', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = []
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='SEIsetInterrupt')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_, name_, pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='SEIsetInterrupt'):
        pass
    def exportChildren(self, outfile, level, namespace_='', name_='SEIsetInterrupt', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.name is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sname>%s</%sname>%s' % (namespace_, self.gds_format_string(quote_xml(self.name).encode(ExternalEncoding), input_name='name'), namespace_, eol_))
        if self.value is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%svalue>%s</%svalue>%s' % (namespace_, self.gds_format_string(quote_xml(self.value).encode(ExternalEncoding), input_name='value'), namespace_, eol_))
        if self.comment is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%scomment>%s</%scomment>%s' % (namespace_, self.gds_format_string(quote_xml(self.comment).encode(ExternalEncoding), input_name='comment'), namespace_, eol_))
    def hasContent_(self):
        if (
            self.name is not None or
            self.value is not None or
            self.comment is not None
            ):
            return True
        else:
            return False
    def exportLiteral(self, outfile, level, name_='SEIsetInterrupt'):
        level += 1
        self.exportLiteralAttributes(outfile, level, [], name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        pass
    def exportLiteralChildren(self, outfile, level, name_):
        if self.name is not None:
            showIndent(outfile, level)
            outfile.write('name=%s,\n' % quote_python(self.name).encode(ExternalEncoding))
        if self.value is not None:
            showIndent(outfile, level)
            outfile.write('value=%s,\n' % quote_python(self.value).encode(ExternalEncoding))
        if self.comment is not None:
            showIndent(outfile, level)
            outfile.write('comment=%s,\n' % quote_python(self.comment).encode(ExternalEncoding))
    def build(self, node):
        self.buildAttributes(node, node.attrib, [])
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'name':
            name_ = child_.text
            name_ = re_.sub(String_cleanup_pat_, " ", name_).strip()
            name_ = self.gds_validate_string(name_, node, 'name')
            self.name = name_
        elif nodeName_ == 'value':
            value_ = child_.text
            value_ = self.gds_validate_string(value_, node, 'value')
            self.value = value_
        elif nodeName_ == 'comment':
            comment_ = child_.text
            comment_ = self.gds_validate_string(comment_, node, 'comment')
            self.comment = comment_
# end class SEIsetInterrupt


class CLVclearOverflow(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, name=None, value=None, comment=None):
        self.name = name
        self.value = value
        self.comment = comment
    def factory(*args_, **kwargs_):
        if CLVclearOverflow.subclass:
            return CLVclearOverflow.subclass(*args_, **kwargs_)
        else:
            return CLVclearOverflow(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_name(self): return self.name
    def set_name(self, name): self.name = name
    def get_value(self): return self.value
    def set_value(self, value): self.value = value
    def get_comment(self): return self.comment
    def set_comment(self, comment): self.comment = comment
    def export(self, outfile, level, namespace_='', name_='CLVclearOverflow', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = []
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='CLVclearOverflow')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_, name_, pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='CLVclearOverflow'):
        pass
    def exportChildren(self, outfile, level, namespace_='', name_='CLVclearOverflow', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.name is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sname>%s</%sname>%s' % (namespace_, self.gds_format_string(quote_xml(self.name).encode(ExternalEncoding), input_name='name'), namespace_, eol_))
        if self.value is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%svalue>%s</%svalue>%s' % (namespace_, self.gds_format_string(quote_xml(self.value).encode(ExternalEncoding), input_name='value'), namespace_, eol_))
        if self.comment is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%scomment>%s</%scomment>%s' % (namespace_, self.gds_format_string(quote_xml(self.comment).encode(ExternalEncoding), input_name='comment'), namespace_, eol_))
    def hasContent_(self):
        if (
            self.name is not None or
            self.value is not None or
            self.comment is not None
            ):
            return True
        else:
            return False
    def exportLiteral(self, outfile, level, name_='CLVclearOverflow'):
        level += 1
        self.exportLiteralAttributes(outfile, level, [], name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        pass
    def exportLiteralChildren(self, outfile, level, name_):
        if self.name is not None:
            showIndent(outfile, level)
            outfile.write('name=%s,\n' % quote_python(self.name).encode(ExternalEncoding))
        if self.value is not None:
            showIndent(outfile, level)
            outfile.write('value=%s,\n' % quote_python(self.value).encode(ExternalEncoding))
        if self.comment is not None:
            showIndent(outfile, level)
            outfile.write('comment=%s,\n' % quote_python(self.comment).encode(ExternalEncoding))
    def build(self, node):
        self.buildAttributes(node, node.attrib, [])
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'name':
            name_ = child_.text
            name_ = re_.sub(String_cleanup_pat_, " ", name_).strip()
            name_ = self.gds_validate_string(name_, node, 'name')
            self.name = name_
        elif nodeName_ == 'value':
            value_ = child_.text
            value_ = self.gds_validate_string(value_, node, 'value')
            self.value = value_
        elif nodeName_ == 'comment':
            comment_ = child_.text
            comment_ = self.gds_validate_string(comment_, node, 'comment')
            self.comment = comment_
# end class CLVclearOverflow


class CLDclearDecimal(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, name=None, value=None, comment=None):
        self.name = name
        self.value = value
        self.comment = comment
    def factory(*args_, **kwargs_):
        if CLDclearDecimal.subclass:
            return CLDclearDecimal.subclass(*args_, **kwargs_)
        else:
            return CLDclearDecimal(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_name(self): return self.name
    def set_name(self, name): self.name = name
    def get_value(self): return self.value
    def set_value(self, value): self.value = value
    def get_comment(self): return self.comment
    def set_comment(self, comment): self.comment = comment
    def export(self, outfile, level, namespace_='', name_='CLDclearDecimal', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = []
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='CLDclearDecimal')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_, name_, pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='CLDclearDecimal'):
        pass
    def exportChildren(self, outfile, level, namespace_='', name_='CLDclearDecimal', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.name is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sname>%s</%sname>%s' % (namespace_, self.gds_format_string(quote_xml(self.name).encode(ExternalEncoding), input_name='name'), namespace_, eol_))
        if self.value is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%svalue>%s</%svalue>%s' % (namespace_, self.gds_format_string(quote_xml(self.value).encode(ExternalEncoding), input_name='value'), namespace_, eol_))
        if self.comment is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%scomment>%s</%scomment>%s' % (namespace_, self.gds_format_string(quote_xml(self.comment).encode(ExternalEncoding), input_name='comment'), namespace_, eol_))
    def hasContent_(self):
        if (
            self.name is not None or
            self.value is not None or
            self.comment is not None
            ):
            return True
        else:
            return False
    def exportLiteral(self, outfile, level, name_='CLDclearDecimal'):
        level += 1
        self.exportLiteralAttributes(outfile, level, [], name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        pass
    def exportLiteralChildren(self, outfile, level, name_):
        if self.name is not None:
            showIndent(outfile, level)
            outfile.write('name=%s,\n' % quote_python(self.name).encode(ExternalEncoding))
        if self.value is not None:
            showIndent(outfile, level)
            outfile.write('value=%s,\n' % quote_python(self.value).encode(ExternalEncoding))
        if self.comment is not None:
            showIndent(outfile, level)
            outfile.write('comment=%s,\n' % quote_python(self.comment).encode(ExternalEncoding))
    def build(self, node):
        self.buildAttributes(node, node.attrib, [])
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'name':
            name_ = child_.text
            name_ = re_.sub(String_cleanup_pat_, " ", name_).strip()
            name_ = self.gds_validate_string(name_, node, 'name')
            self.name = name_
        elif nodeName_ == 'value':
            value_ = child_.text
            value_ = self.gds_validate_string(value_, node, 'value')
            self.value = value_
        elif nodeName_ == 'comment':
            comment_ = child_.text
            comment_ = self.gds_validate_string(comment_, node, 'comment')
            self.comment = comment_
# end class CLDclearDecimal


class SEDsetDecimal(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, name=None, value=None, comment=None):
        self.name = name
        self.value = value
        self.comment = comment
    def factory(*args_, **kwargs_):
        if SEDsetDecimal.subclass:
            return SEDsetDecimal.subclass(*args_, **kwargs_)
        else:
            return SEDsetDecimal(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_name(self): return self.name
    def set_name(self, name): self.name = name
    def get_value(self): return self.value
    def set_value(self, value): self.value = value
    def get_comment(self): return self.comment
    def set_comment(self, comment): self.comment = comment
    def export(self, outfile, level, namespace_='', name_='SEDsetDecimal', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = []
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='SEDsetDecimal')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_, name_, pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='SEDsetDecimal'):
        pass
    def exportChildren(self, outfile, level, namespace_='', name_='SEDsetDecimal', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.name is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sname>%s</%sname>%s' % (namespace_, self.gds_format_string(quote_xml(self.name).encode(ExternalEncoding), input_name='name'), namespace_, eol_))
        if self.value is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%svalue>%s</%svalue>%s' % (namespace_, self.gds_format_string(quote_xml(self.value).encode(ExternalEncoding), input_name='value'), namespace_, eol_))
        if self.comment is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%scomment>%s</%scomment>%s' % (namespace_, self.gds_format_string(quote_xml(self.comment).encode(ExternalEncoding), input_name='comment'), namespace_, eol_))
    def hasContent_(self):
        if (
            self.name is not None or
            self.value is not None or
            self.comment is not None
            ):
            return True
        else:
            return False
    def exportLiteral(self, outfile, level, name_='SEDsetDecimal'):
        level += 1
        self.exportLiteralAttributes(outfile, level, [], name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        pass
    def exportLiteralChildren(self, outfile, level, name_):
        if self.name is not None:
            showIndent(outfile, level)
            outfile.write('name=%s,\n' % quote_python(self.name).encode(ExternalEncoding))
        if self.value is not None:
            showIndent(outfile, level)
            outfile.write('value=%s,\n' % quote_python(self.value).encode(ExternalEncoding))
        if self.comment is not None:
            showIndent(outfile, level)
            outfile.write('comment=%s,\n' % quote_python(self.comment).encode(ExternalEncoding))
    def build(self, node):
        self.buildAttributes(node, node.attrib, [])
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'name':
            name_ = child_.text
            name_ = re_.sub(String_cleanup_pat_, " ", name_).strip()
            name_ = self.gds_validate_string(name_, node, 'name')
            self.name = name_
        elif nodeName_ == 'value':
            value_ = child_.text
            value_ = self.gds_validate_string(value_, node, 'value')
            self.value = value_
        elif nodeName_ == 'comment':
            comment_ = child_.text
            comment_ = self.gds_validate_string(comment_, node, 'comment')
            self.comment = comment_
# end class SEDsetDecimal


class INCincrementMemory(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, name=None, value=None, comment=None):
        self.name = name
        if value is None:
            self.value = []
        else:
            self.value = value
        self.comment = comment
    def factory(*args_, **kwargs_):
        if INCincrementMemory.subclass:
            return INCincrementMemory.subclass(*args_, **kwargs_)
        else:
            return INCincrementMemory(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_name(self): return self.name
    def set_name(self, name): self.name = name
    def get_value(self): return self.value
    def set_value(self, value): self.value = value
    def add_value(self, value): self.value.append(value)
    def insert_value(self, index, value): self.value[index] = value
    def get_comment(self): return self.comment
    def set_comment(self, comment): self.comment = comment
    def export(self, outfile, level, namespace_='', name_='INCincrementMemory', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = []
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='INCincrementMemory')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_, name_, pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='INCincrementMemory'):
        pass
    def exportChildren(self, outfile, level, namespace_='', name_='INCincrementMemory', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.name is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sname>%s</%sname>%s' % (namespace_, self.gds_format_string(quote_xml(self.name).encode(ExternalEncoding), input_name='name'), namespace_, eol_))
        for value_ in self.value:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%svalue>%s</%svalue>%s' % (namespace_, self.gds_format_string(quote_xml(value_).encode(ExternalEncoding), input_name='value'), namespace_, eol_))
        if self.comment is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%scomment>%s</%scomment>%s' % (namespace_, self.gds_format_string(quote_xml(self.comment).encode(ExternalEncoding), input_name='comment'), namespace_, eol_))
    def hasContent_(self):
        if (
            self.name is not None or
            self.value or
            self.comment is not None
            ):
            return True
        else:
            return False
    def exportLiteral(self, outfile, level, name_='INCincrementMemory'):
        level += 1
        self.exportLiteralAttributes(outfile, level, [], name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        pass
    def exportLiteralChildren(self, outfile, level, name_):
        if self.name is not None:
            showIndent(outfile, level)
            outfile.write('name=%s,\n' % quote_python(self.name).encode(ExternalEncoding))
        showIndent(outfile, level)
        outfile.write('value=[\n')
        level += 1
        for value_ in self.value:
            showIndent(outfile, level)
            outfile.write('%s,\n' % quote_python(value_).encode(ExternalEncoding))
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
        if self.comment is not None:
            showIndent(outfile, level)
            outfile.write('comment=%s,\n' % quote_python(self.comment).encode(ExternalEncoding))
    def build(self, node):
        self.buildAttributes(node, node.attrib, [])
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'name':
            name_ = child_.text
            name_ = re_.sub(String_cleanup_pat_, " ", name_).strip()
            name_ = self.gds_validate_string(name_, node, 'name')
            self.name = name_
        elif nodeName_ == 'value':
            value_ = child_.text
            value_ = self.gds_validate_string(value_, node, 'value')
            self.value.append(value_)
        elif nodeName_ == 'comment':
            comment_ = child_.text
            comment_ = self.gds_validate_string(comment_, node, 'comment')
            self.comment = comment_
# end class INCincrementMemory


class JMPjump(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, name=None, value=None, comment=None):
        self.name = name
        if value is None:
            self.value = []
        else:
            self.value = value
        self.comment = comment
    def factory(*args_, **kwargs_):
        if JMPjump.subclass:
            return JMPjump.subclass(*args_, **kwargs_)
        else:
            return JMPjump(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_name(self): return self.name
    def set_name(self, name): self.name = name
    def get_value(self): return self.value
    def set_value(self, value): self.value = value
    def add_value(self, value): self.value.append(value)
    def insert_value(self, index, value): self.value[index] = value
    def get_comment(self): return self.comment
    def set_comment(self, comment): self.comment = comment
    def export(self, outfile, level, namespace_='', name_='JMPjump', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = []
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='JMPjump')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_, name_, pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='JMPjump'):
        pass
    def exportChildren(self, outfile, level, namespace_='', name_='JMPjump', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.name is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sname>%s</%sname>%s' % (namespace_, self.gds_format_string(quote_xml(self.name).encode(ExternalEncoding), input_name='name'), namespace_, eol_))
        for value_ in self.value:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%svalue>%s</%svalue>%s' % (namespace_, self.gds_format_string(quote_xml(value_).encode(ExternalEncoding), input_name='value'), namespace_, eol_))
        if self.comment is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%scomment>%s</%scomment>%s' % (namespace_, self.gds_format_string(quote_xml(self.comment).encode(ExternalEncoding), input_name='comment'), namespace_, eol_))
    def hasContent_(self):
        if (
            self.name is not None or
            self.value or
            self.comment is not None
            ):
            return True
        else:
            return False
    def exportLiteral(self, outfile, level, name_='JMPjump'):
        level += 1
        self.exportLiteralAttributes(outfile, level, [], name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        pass
    def exportLiteralChildren(self, outfile, level, name_):
        if self.name is not None:
            showIndent(outfile, level)
            outfile.write('name=%s,\n' % quote_python(self.name).encode(ExternalEncoding))
        showIndent(outfile, level)
        outfile.write('value=[\n')
        level += 1
        for value_ in self.value:
            showIndent(outfile, level)
            outfile.write('%s,\n' % quote_python(value_).encode(ExternalEncoding))
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
        if self.comment is not None:
            showIndent(outfile, level)
            outfile.write('comment=%s,\n' % quote_python(self.comment).encode(ExternalEncoding))
    def build(self, node):
        self.buildAttributes(node, node.attrib, [])
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'name':
            name_ = child_.text
            name_ = re_.sub(String_cleanup_pat_, " ", name_).strip()
            name_ = self.gds_validate_string(name_, node, 'name')
            self.name = name_
        elif nodeName_ == 'value':
            value_ = child_.text
            value_ = self.gds_validate_string(value_, node, 'value')
            self.value.append(value_)
        elif nodeName_ == 'comment':
            comment_ = child_.text
            comment_ = self.gds_validate_string(comment_, node, 'comment')
            self.comment = comment_
# end class JMPjump


class JSRjumpToSubRoutine(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, name=None, value=None, comment=None):
        self.name = name
        if value is None:
            self.value = []
        else:
            self.value = value
        self.comment = comment
    def factory(*args_, **kwargs_):
        if JSRjumpToSubRoutine.subclass:
            return JSRjumpToSubRoutine.subclass(*args_, **kwargs_)
        else:
            return JSRjumpToSubRoutine(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_name(self): return self.name
    def set_name(self, name): self.name = name
    def get_value(self): return self.value
    def set_value(self, value): self.value = value
    def add_value(self, value): self.value.append(value)
    def insert_value(self, index, value): self.value[index] = value
    def get_comment(self): return self.comment
    def set_comment(self, comment): self.comment = comment
    def export(self, outfile, level, namespace_='', name_='JSRjumpToSubRoutine', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = []
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='JSRjumpToSubRoutine')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_, name_, pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='JSRjumpToSubRoutine'):
        pass
    def exportChildren(self, outfile, level, namespace_='', name_='JSRjumpToSubRoutine', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.name is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sname>%s</%sname>%s' % (namespace_, self.gds_format_string(quote_xml(self.name).encode(ExternalEncoding), input_name='name'), namespace_, eol_))
        for value_ in self.value:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%svalue>%s</%svalue>%s' % (namespace_, self.gds_format_string(quote_xml(value_).encode(ExternalEncoding), input_name='value'), namespace_, eol_))
        if self.comment is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%scomment>%s</%scomment>%s' % (namespace_, self.gds_format_string(quote_xml(self.comment).encode(ExternalEncoding), input_name='comment'), namespace_, eol_))
    def hasContent_(self):
        if (
            self.name is not None or
            self.value or
            self.comment is not None
            ):
            return True
        else:
            return False
    def exportLiteral(self, outfile, level, name_='JSRjumpToSubRoutine'):
        level += 1
        self.exportLiteralAttributes(outfile, level, [], name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        pass
    def exportLiteralChildren(self, outfile, level, name_):
        if self.name is not None:
            showIndent(outfile, level)
            outfile.write('name=%s,\n' % quote_python(self.name).encode(ExternalEncoding))
        showIndent(outfile, level)
        outfile.write('value=[\n')
        level += 1
        for value_ in self.value:
            showIndent(outfile, level)
            outfile.write('%s,\n' % quote_python(value_).encode(ExternalEncoding))
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
        if self.comment is not None:
            showIndent(outfile, level)
            outfile.write('comment=%s,\n' % quote_python(self.comment).encode(ExternalEncoding))
    def build(self, node):
        self.buildAttributes(node, node.attrib, [])
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'name':
            name_ = child_.text
            name_ = re_.sub(String_cleanup_pat_, " ", name_).strip()
            name_ = self.gds_validate_string(name_, node, 'name')
            self.name = name_
        elif nodeName_ == 'value':
            value_ = child_.text
            value_ = self.gds_validate_string(value_, node, 'value')
            self.value.append(value_)
        elif nodeName_ == 'comment':
            comment_ = child_.text
            comment_ = self.gds_validate_string(comment_, node, 'comment')
            self.comment = comment_
# end class JSRjumpToSubRoutine


class LDAloadAccumulator(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, name=None, value=None, comment=None):
        self.name = name
        if value is None:
            self.value = []
        else:
            self.value = value
        self.comment = comment
    def factory(*args_, **kwargs_):
        if LDAloadAccumulator.subclass:
            return LDAloadAccumulator.subclass(*args_, **kwargs_)
        else:
            return LDAloadAccumulator(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_name(self): return self.name
    def set_name(self, name): self.name = name
    def get_value(self): return self.value
    def set_value(self, value): self.value = value
    def add_value(self, value): self.value.append(value)
    def insert_value(self, index, value): self.value[index] = value
    def get_comment(self): return self.comment
    def set_comment(self, comment): self.comment = comment
    def export(self, outfile, level, namespace_='', name_='LDAloadAccumulator', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = []
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='LDAloadAccumulator')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_, name_, pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='LDAloadAccumulator'):
        pass
    def exportChildren(self, outfile, level, namespace_='', name_='LDAloadAccumulator', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.name is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sname>%s</%sname>%s' % (namespace_, self.gds_format_string(quote_xml(self.name).encode(ExternalEncoding), input_name='name'), namespace_, eol_))
        for value_ in self.value:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%svalue>%s</%svalue>%s' % (namespace_, self.gds_format_string(quote_xml(value_).encode(ExternalEncoding), input_name='value'), namespace_, eol_))
        if self.comment is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%scomment>%s</%scomment>%s' % (namespace_, self.gds_format_string(quote_xml(self.comment).encode(ExternalEncoding), input_name='comment'), namespace_, eol_))
    def hasContent_(self):
        if (
            self.name is not None or
            self.value or
            self.comment is not None
            ):
            return True
        else:
            return False
    def exportLiteral(self, outfile, level, name_='LDAloadAccumulator'):
        level += 1
        self.exportLiteralAttributes(outfile, level, [], name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        pass
    def exportLiteralChildren(self, outfile, level, name_):
        if self.name is not None:
            showIndent(outfile, level)
            outfile.write('name=%s,\n' % quote_python(self.name).encode(ExternalEncoding))
        showIndent(outfile, level)
        outfile.write('value=[\n')
        level += 1
        for value_ in self.value:
            showIndent(outfile, level)
            outfile.write('%s,\n' % quote_python(value_).encode(ExternalEncoding))
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
        if self.comment is not None:
            showIndent(outfile, level)
            outfile.write('comment=%s,\n' % quote_python(self.comment).encode(ExternalEncoding))
    def build(self, node):
        self.buildAttributes(node, node.attrib, [])
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'name':
            name_ = child_.text
            name_ = re_.sub(String_cleanup_pat_, " ", name_).strip()
            name_ = self.gds_validate_string(name_, node, 'name')
            self.name = name_
        elif nodeName_ == 'value':
            value_ = child_.text
            value_ = self.gds_validate_string(value_, node, 'value')
            self.value.append(value_)
        elif nodeName_ == 'comment':
            comment_ = child_.text
            comment_ = self.gds_validate_string(comment_, node, 'comment')
            self.comment = comment_
# end class LDAloadAccumulator


class LDXloadXRegister(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, name=None, value=None, comment=None):
        self.name = name
        if value is None:
            self.value = []
        else:
            self.value = value
        self.comment = comment
    def factory(*args_, **kwargs_):
        if LDXloadXRegister.subclass:
            return LDXloadXRegister.subclass(*args_, **kwargs_)
        else:
            return LDXloadXRegister(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_name(self): return self.name
    def set_name(self, name): self.name = name
    def get_value(self): return self.value
    def set_value(self, value): self.value = value
    def add_value(self, value): self.value.append(value)
    def insert_value(self, index, value): self.value[index] = value
    def get_comment(self): return self.comment
    def set_comment(self, comment): self.comment = comment
    def export(self, outfile, level, namespace_='', name_='LDXloadXRegister', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = []
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='LDXloadXRegister')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_, name_, pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='LDXloadXRegister'):
        pass
    def exportChildren(self, outfile, level, namespace_='', name_='LDXloadXRegister', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.name is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sname>%s</%sname>%s' % (namespace_, self.gds_format_string(quote_xml(self.name).encode(ExternalEncoding), input_name='name'), namespace_, eol_))
        for value_ in self.value:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%svalue>%s</%svalue>%s' % (namespace_, self.gds_format_string(quote_xml(value_).encode(ExternalEncoding), input_name='value'), namespace_, eol_))
        if self.comment is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%scomment>%s</%scomment>%s' % (namespace_, self.gds_format_string(quote_xml(self.comment).encode(ExternalEncoding), input_name='comment'), namespace_, eol_))
    def hasContent_(self):
        if (
            self.name is not None or
            self.value or
            self.comment is not None
            ):
            return True
        else:
            return False
    def exportLiteral(self, outfile, level, name_='LDXloadXRegister'):
        level += 1
        self.exportLiteralAttributes(outfile, level, [], name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        pass
    def exportLiteralChildren(self, outfile, level, name_):
        if self.name is not None:
            showIndent(outfile, level)
            outfile.write('name=%s,\n' % quote_python(self.name).encode(ExternalEncoding))
        showIndent(outfile, level)
        outfile.write('value=[\n')
        level += 1
        for value_ in self.value:
            showIndent(outfile, level)
            outfile.write('%s,\n' % quote_python(value_).encode(ExternalEncoding))
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
        if self.comment is not None:
            showIndent(outfile, level)
            outfile.write('comment=%s,\n' % quote_python(self.comment).encode(ExternalEncoding))
    def build(self, node):
        self.buildAttributes(node, node.attrib, [])
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'name':
            name_ = child_.text
            name_ = re_.sub(String_cleanup_pat_, " ", name_).strip()
            name_ = self.gds_validate_string(name_, node, 'name')
            self.name = name_
        elif nodeName_ == 'value':
            value_ = child_.text
            value_ = self.gds_validate_string(value_, node, 'value')
            self.value.append(value_)
        elif nodeName_ == 'comment':
            comment_ = child_.text
            comment_ = self.gds_validate_string(comment_, node, 'comment')
            self.comment = comment_
# end class LDXloadXRegister


class LDYloadYRegister(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, name=None, value=None, comment=None):
        self.name = name
        if value is None:
            self.value = []
        else:
            self.value = value
        self.comment = comment
    def factory(*args_, **kwargs_):
        if LDYloadYRegister.subclass:
            return LDYloadYRegister.subclass(*args_, **kwargs_)
        else:
            return LDYloadYRegister(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_name(self): return self.name
    def set_name(self, name): self.name = name
    def get_value(self): return self.value
    def set_value(self, value): self.value = value
    def add_value(self, value): self.value.append(value)
    def insert_value(self, index, value): self.value[index] = value
    def get_comment(self): return self.comment
    def set_comment(self, comment): self.comment = comment
    def export(self, outfile, level, namespace_='', name_='LDYloadYRegister', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = []
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='LDYloadYRegister')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_, name_, pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='LDYloadYRegister'):
        pass
    def exportChildren(self, outfile, level, namespace_='', name_='LDYloadYRegister', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.name is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sname>%s</%sname>%s' % (namespace_, self.gds_format_string(quote_xml(self.name).encode(ExternalEncoding), input_name='name'), namespace_, eol_))
        for value_ in self.value:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%svalue>%s</%svalue>%s' % (namespace_, self.gds_format_string(quote_xml(value_).encode(ExternalEncoding), input_name='value'), namespace_, eol_))
        if self.comment is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%scomment>%s</%scomment>%s' % (namespace_, self.gds_format_string(quote_xml(self.comment).encode(ExternalEncoding), input_name='comment'), namespace_, eol_))
    def hasContent_(self):
        if (
            self.name is not None or
            self.value or
            self.comment is not None
            ):
            return True
        else:
            return False
    def exportLiteral(self, outfile, level, name_='LDYloadYRegister'):
        level += 1
        self.exportLiteralAttributes(outfile, level, [], name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        pass
    def exportLiteralChildren(self, outfile, level, name_):
        if self.name is not None:
            showIndent(outfile, level)
            outfile.write('name=%s,\n' % quote_python(self.name).encode(ExternalEncoding))
        showIndent(outfile, level)
        outfile.write('value=[\n')
        level += 1
        for value_ in self.value:
            showIndent(outfile, level)
            outfile.write('%s,\n' % quote_python(value_).encode(ExternalEncoding))
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
        if self.comment is not None:
            showIndent(outfile, level)
            outfile.write('comment=%s,\n' % quote_python(self.comment).encode(ExternalEncoding))
    def build(self, node):
        self.buildAttributes(node, node.attrib, [])
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'name':
            name_ = child_.text
            name_ = re_.sub(String_cleanup_pat_, " ", name_).strip()
            name_ = self.gds_validate_string(name_, node, 'name')
            self.name = name_
        elif nodeName_ == 'value':
            value_ = child_.text
            value_ = self.gds_validate_string(value_, node, 'value')
            self.value.append(value_)
        elif nodeName_ == 'comment':
            comment_ = child_.text
            comment_ = self.gds_validate_string(comment_, node, 'comment')
            self.comment = comment_
# end class LDYloadYRegister


class LSRlogicalShiftRight(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, name=None, value=None, comment=None):
        self.name = name
        if value is None:
            self.value = []
        else:
            self.value = value
        self.comment = comment
    def factory(*args_, **kwargs_):
        if LSRlogicalShiftRight.subclass:
            return LSRlogicalShiftRight.subclass(*args_, **kwargs_)
        else:
            return LSRlogicalShiftRight(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_name(self): return self.name
    def set_name(self, name): self.name = name
    def get_value(self): return self.value
    def set_value(self, value): self.value = value
    def add_value(self, value): self.value.append(value)
    def insert_value(self, index, value): self.value[index] = value
    def get_comment(self): return self.comment
    def set_comment(self, comment): self.comment = comment
    def export(self, outfile, level, namespace_='', name_='LSRlogicalShiftRight', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = []
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='LSRlogicalShiftRight')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_, name_, pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='LSRlogicalShiftRight'):
        pass
    def exportChildren(self, outfile, level, namespace_='', name_='LSRlogicalShiftRight', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.name is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sname>%s</%sname>%s' % (namespace_, self.gds_format_string(quote_xml(self.name).encode(ExternalEncoding), input_name='name'), namespace_, eol_))
        for value_ in self.value:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%svalue>%s</%svalue>%s' % (namespace_, self.gds_format_string(quote_xml(value_).encode(ExternalEncoding), input_name='value'), namespace_, eol_))
        if self.comment is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%scomment>%s</%scomment>%s' % (namespace_, self.gds_format_string(quote_xml(self.comment).encode(ExternalEncoding), input_name='comment'), namespace_, eol_))
    def hasContent_(self):
        if (
            self.name is not None or
            self.value or
            self.comment is not None
            ):
            return True
        else:
            return False
    def exportLiteral(self, outfile, level, name_='LSRlogicalShiftRight'):
        level += 1
        self.exportLiteralAttributes(outfile, level, [], name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        pass
    def exportLiteralChildren(self, outfile, level, name_):
        if self.name is not None:
            showIndent(outfile, level)
            outfile.write('name=%s,\n' % quote_python(self.name).encode(ExternalEncoding))
        showIndent(outfile, level)
        outfile.write('value=[\n')
        level += 1
        for value_ in self.value:
            showIndent(outfile, level)
            outfile.write('%s,\n' % quote_python(value_).encode(ExternalEncoding))
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
        if self.comment is not None:
            showIndent(outfile, level)
            outfile.write('comment=%s,\n' % quote_python(self.comment).encode(ExternalEncoding))
    def build(self, node):
        self.buildAttributes(node, node.attrib, [])
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'name':
            name_ = child_.text
            name_ = re_.sub(String_cleanup_pat_, " ", name_).strip()
            name_ = self.gds_validate_string(name_, node, 'name')
            self.name = name_
        elif nodeName_ == 'value':
            value_ = child_.text
            value_ = self.gds_validate_string(value_, node, 'value')
            self.value.append(value_)
        elif nodeName_ == 'comment':
            comment_ = child_.text
            comment_ = self.gds_validate_string(comment_, node, 'comment')
            self.comment = comment_
# end class LSRlogicalShiftRight


class NOPnoOperation(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, name=None, value=None, comment=None):
        self.name = name
        if value is None:
            self.value = []
        else:
            self.value = value
        self.comment = comment
    def factory(*args_, **kwargs_):
        if NOPnoOperation.subclass:
            return NOPnoOperation.subclass(*args_, **kwargs_)
        else:
            return NOPnoOperation(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_name(self): return self.name
    def set_name(self, name): self.name = name
    def get_value(self): return self.value
    def set_value(self, value): self.value = value
    def add_value(self, value): self.value.append(value)
    def insert_value(self, index, value): self.value[index] = value
    def get_comment(self): return self.comment
    def set_comment(self, comment): self.comment = comment
    def export(self, outfile, level, namespace_='', name_='NOPnoOperation', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = []
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='NOPnoOperation')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_, name_, pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='NOPnoOperation'):
        pass
    def exportChildren(self, outfile, level, namespace_='', name_='NOPnoOperation', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.name is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sname>%s</%sname>%s' % (namespace_, self.gds_format_string(quote_xml(self.name).encode(ExternalEncoding), input_name='name'), namespace_, eol_))
        for value_ in self.value:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%svalue>%s</%svalue>%s' % (namespace_, self.gds_format_string(quote_xml(value_).encode(ExternalEncoding), input_name='value'), namespace_, eol_))
        if self.comment is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%scomment>%s</%scomment>%s' % (namespace_, self.gds_format_string(quote_xml(self.comment).encode(ExternalEncoding), input_name='comment'), namespace_, eol_))
    def hasContent_(self):
        if (
            self.name is not None or
            self.value or
            self.comment is not None
            ):
            return True
        else:
            return False
    def exportLiteral(self, outfile, level, name_='NOPnoOperation'):
        level += 1
        self.exportLiteralAttributes(outfile, level, [], name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        pass
    def exportLiteralChildren(self, outfile, level, name_):
        if self.name is not None:
            showIndent(outfile, level)
            outfile.write('name=%s,\n' % quote_python(self.name).encode(ExternalEncoding))
        showIndent(outfile, level)
        outfile.write('value=[\n')
        level += 1
        for value_ in self.value:
            showIndent(outfile, level)
            outfile.write('%s,\n' % quote_python(value_).encode(ExternalEncoding))
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
        if self.comment is not None:
            showIndent(outfile, level)
            outfile.write('comment=%s,\n' % quote_python(self.comment).encode(ExternalEncoding))
    def build(self, node):
        self.buildAttributes(node, node.attrib, [])
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'name':
            name_ = child_.text
            name_ = re_.sub(String_cleanup_pat_, " ", name_).strip()
            name_ = self.gds_validate_string(name_, node, 'name')
            self.name = name_
        elif nodeName_ == 'value':
            value_ = child_.text
            value_ = self.gds_validate_string(value_, node, 'value')
            self.value.append(value_)
        elif nodeName_ == 'comment':
            comment_ = child_.text
            comment_ = self.gds_validate_string(comment_, node, 'comment')
            self.comment = comment_
# end class NOPnoOperation


class ORAbitwiseOrWithAccumulator(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, name=None, value=None, comment=None):
        self.name = name
        if value is None:
            self.value = []
        else:
            self.value = value
        self.comment = comment
    def factory(*args_, **kwargs_):
        if ORAbitwiseOrWithAccumulator.subclass:
            return ORAbitwiseOrWithAccumulator.subclass(*args_, **kwargs_)
        else:
            return ORAbitwiseOrWithAccumulator(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_name(self): return self.name
    def set_name(self, name): self.name = name
    def get_value(self): return self.value
    def set_value(self, value): self.value = value
    def add_value(self, value): self.value.append(value)
    def insert_value(self, index, value): self.value[index] = value
    def get_comment(self): return self.comment
    def set_comment(self, comment): self.comment = comment
    def export(self, outfile, level, namespace_='', name_='ORAbitwiseOrWithAccumulator', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = []
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='ORAbitwiseOrWithAccumulator')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_, name_, pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='ORAbitwiseOrWithAccumulator'):
        pass
    def exportChildren(self, outfile, level, namespace_='', name_='ORAbitwiseOrWithAccumulator', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.name is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sname>%s</%sname>%s' % (namespace_, self.gds_format_string(quote_xml(self.name).encode(ExternalEncoding), input_name='name'), namespace_, eol_))
        for value_ in self.value:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%svalue>%s</%svalue>%s' % (namespace_, self.gds_format_string(quote_xml(value_).encode(ExternalEncoding), input_name='value'), namespace_, eol_))
        if self.comment is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%scomment>%s</%scomment>%s' % (namespace_, self.gds_format_string(quote_xml(self.comment).encode(ExternalEncoding), input_name='comment'), namespace_, eol_))
    def hasContent_(self):
        if (
            self.name is not None or
            self.value or
            self.comment is not None
            ):
            return True
        else:
            return False
    def exportLiteral(self, outfile, level, name_='ORAbitwiseOrWithAccumulator'):
        level += 1
        self.exportLiteralAttributes(outfile, level, [], name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        pass
    def exportLiteralChildren(self, outfile, level, name_):
        if self.name is not None:
            showIndent(outfile, level)
            outfile.write('name=%s,\n' % quote_python(self.name).encode(ExternalEncoding))
        showIndent(outfile, level)
        outfile.write('value=[\n')
        level += 1
        for value_ in self.value:
            showIndent(outfile, level)
            outfile.write('%s,\n' % quote_python(value_).encode(ExternalEncoding))
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
        if self.comment is not None:
            showIndent(outfile, level)
            outfile.write('comment=%s,\n' % quote_python(self.comment).encode(ExternalEncoding))
    def build(self, node):
        self.buildAttributes(node, node.attrib, [])
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'name':
            name_ = child_.text
            name_ = re_.sub(String_cleanup_pat_, " ", name_).strip()
            name_ = self.gds_validate_string(name_, node, 'name')
            self.name = name_
        elif nodeName_ == 'value':
            value_ = child_.text
            value_ = self.gds_validate_string(value_, node, 'value')
            self.value.append(value_)
        elif nodeName_ == 'comment':
            comment_ = child_.text
            comment_ = self.gds_validate_string(comment_, node, 'comment')
            self.comment = comment_
# end class ORAbitwiseOrWithAccumulator


class TAXTtansferAtoX(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, name=None, value=None, comment=None):
        self.name = name
        self.value = value
        self.comment = comment
    def factory(*args_, **kwargs_):
        if TAXTtansferAtoX.subclass:
            return TAXTtansferAtoX.subclass(*args_, **kwargs_)
        else:
            return TAXTtansferAtoX(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_name(self): return self.name
    def set_name(self, name): self.name = name
    def get_value(self): return self.value
    def set_value(self, value): self.value = value
    def get_comment(self): return self.comment
    def set_comment(self, comment): self.comment = comment
    def export(self, outfile, level, namespace_='', name_='TAXTtansferAtoX', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = []
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='TAXTtansferAtoX')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_, name_, pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='TAXTtansferAtoX'):
        pass
    def exportChildren(self, outfile, level, namespace_='', name_='TAXTtansferAtoX', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.name is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sname>%s</%sname>%s' % (namespace_, self.gds_format_string(quote_xml(self.name).encode(ExternalEncoding), input_name='name'), namespace_, eol_))
        if self.value is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%svalue>%s</%svalue>%s' % (namespace_, self.gds_format_string(quote_xml(self.value).encode(ExternalEncoding), input_name='value'), namespace_, eol_))
        if self.comment is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%scomment>%s</%scomment>%s' % (namespace_, self.gds_format_string(quote_xml(self.comment).encode(ExternalEncoding), input_name='comment'), namespace_, eol_))
    def hasContent_(self):
        if (
            self.name is not None or
            self.value is not None or
            self.comment is not None
            ):
            return True
        else:
            return False
    def exportLiteral(self, outfile, level, name_='TAXTtansferAtoX'):
        level += 1
        self.exportLiteralAttributes(outfile, level, [], name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        pass
    def exportLiteralChildren(self, outfile, level, name_):
        if self.name is not None:
            showIndent(outfile, level)
            outfile.write('name=%s,\n' % quote_python(self.name).encode(ExternalEncoding))
        if self.value is not None:
            showIndent(outfile, level)
            outfile.write('value=%s,\n' % quote_python(self.value).encode(ExternalEncoding))
        if self.comment is not None:
            showIndent(outfile, level)
            outfile.write('comment=%s,\n' % quote_python(self.comment).encode(ExternalEncoding))
    def build(self, node):
        self.buildAttributes(node, node.attrib, [])
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'name':
            name_ = child_.text
            name_ = re_.sub(String_cleanup_pat_, " ", name_).strip()
            name_ = self.gds_validate_string(name_, node, 'name')
            self.name = name_
        elif nodeName_ == 'value':
            value_ = child_.text
            value_ = self.gds_validate_string(value_, node, 'value')
            self.value = value_
        elif nodeName_ == 'comment':
            comment_ = child_.text
            comment_ = self.gds_validate_string(comment_, node, 'comment')
            self.comment = comment_
# end class TAXTtansferAtoX


class TXAtransferXtoA(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, name=None, value=None, comment=None):
        self.name = name
        self.value = value
        self.comment = comment
    def factory(*args_, **kwargs_):
        if TXAtransferXtoA.subclass:
            return TXAtransferXtoA.subclass(*args_, **kwargs_)
        else:
            return TXAtransferXtoA(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_name(self): return self.name
    def set_name(self, name): self.name = name
    def get_value(self): return self.value
    def set_value(self, value): self.value = value
    def get_comment(self): return self.comment
    def set_comment(self, comment): self.comment = comment
    def export(self, outfile, level, namespace_='', name_='TXAtransferXtoA', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = []
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='TXAtransferXtoA')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_, name_, pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='TXAtransferXtoA'):
        pass
    def exportChildren(self, outfile, level, namespace_='', name_='TXAtransferXtoA', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.name is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sname>%s</%sname>%s' % (namespace_, self.gds_format_string(quote_xml(self.name).encode(ExternalEncoding), input_name='name'), namespace_, eol_))
        if self.value is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%svalue>%s</%svalue>%s' % (namespace_, self.gds_format_string(quote_xml(self.value).encode(ExternalEncoding), input_name='value'), namespace_, eol_))
        if self.comment is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%scomment>%s</%scomment>%s' % (namespace_, self.gds_format_string(quote_xml(self.comment).encode(ExternalEncoding), input_name='comment'), namespace_, eol_))
    def hasContent_(self):
        if (
            self.name is not None or
            self.value is not None or
            self.comment is not None
            ):
            return True
        else:
            return False
    def exportLiteral(self, outfile, level, name_='TXAtransferXtoA'):
        level += 1
        self.exportLiteralAttributes(outfile, level, [], name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        pass
    def exportLiteralChildren(self, outfile, level, name_):
        if self.name is not None:
            showIndent(outfile, level)
            outfile.write('name=%s,\n' % quote_python(self.name).encode(ExternalEncoding))
        if self.value is not None:
            showIndent(outfile, level)
            outfile.write('value=%s,\n' % quote_python(self.value).encode(ExternalEncoding))
        if self.comment is not None:
            showIndent(outfile, level)
            outfile.write('comment=%s,\n' % quote_python(self.comment).encode(ExternalEncoding))
    def build(self, node):
        self.buildAttributes(node, node.attrib, [])
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'name':
            name_ = child_.text
            name_ = re_.sub(String_cleanup_pat_, " ", name_).strip()
            name_ = self.gds_validate_string(name_, node, 'name')
            self.name = name_
        elif nodeName_ == 'value':
            value_ = child_.text
            value_ = self.gds_validate_string(value_, node, 'value')
            self.value = value_
        elif nodeName_ == 'comment':
            comment_ = child_.text
            comment_ = self.gds_validate_string(comment_, node, 'comment')
            self.comment = comment_
# end class TXAtransferXtoA


class DEXdecrementX(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, name=None, value=None, comment=None):
        self.name = name
        self.value = value
        self.comment = comment
    def factory(*args_, **kwargs_):
        if DEXdecrementX.subclass:
            return DEXdecrementX.subclass(*args_, **kwargs_)
        else:
            return DEXdecrementX(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_name(self): return self.name
    def set_name(self, name): self.name = name
    def get_value(self): return self.value
    def set_value(self, value): self.value = value
    def get_comment(self): return self.comment
    def set_comment(self, comment): self.comment = comment
    def export(self, outfile, level, namespace_='', name_='DEXdecrementX', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = []
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='DEXdecrementX')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_, name_, pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='DEXdecrementX'):
        pass
    def exportChildren(self, outfile, level, namespace_='', name_='DEXdecrementX', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.name is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sname>%s</%sname>%s' % (namespace_, self.gds_format_string(quote_xml(self.name).encode(ExternalEncoding), input_name='name'), namespace_, eol_))
        if self.value is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%svalue>%s</%svalue>%s' % (namespace_, self.gds_format_string(quote_xml(self.value).encode(ExternalEncoding), input_name='value'), namespace_, eol_))
        if self.comment is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%scomment>%s</%scomment>%s' % (namespace_, self.gds_format_string(quote_xml(self.comment).encode(ExternalEncoding), input_name='comment'), namespace_, eol_))
    def hasContent_(self):
        if (
            self.name is not None or
            self.value is not None or
            self.comment is not None
            ):
            return True
        else:
            return False
    def exportLiteral(self, outfile, level, name_='DEXdecrementX'):
        level += 1
        self.exportLiteralAttributes(outfile, level, [], name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        pass
    def exportLiteralChildren(self, outfile, level, name_):
        if self.name is not None:
            showIndent(outfile, level)
            outfile.write('name=%s,\n' % quote_python(self.name).encode(ExternalEncoding))
        if self.value is not None:
            showIndent(outfile, level)
            outfile.write('value=%s,\n' % quote_python(self.value).encode(ExternalEncoding))
        if self.comment is not None:
            showIndent(outfile, level)
            outfile.write('comment=%s,\n' % quote_python(self.comment).encode(ExternalEncoding))
    def build(self, node):
        self.buildAttributes(node, node.attrib, [])
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'name':
            name_ = child_.text
            name_ = re_.sub(String_cleanup_pat_, " ", name_).strip()
            name_ = self.gds_validate_string(name_, node, 'name')
            self.name = name_
        elif nodeName_ == 'value':
            value_ = child_.text
            value_ = self.gds_validate_string(value_, node, 'value')
            self.value = value_
        elif nodeName_ == 'comment':
            comment_ = child_.text
            comment_ = self.gds_validate_string(comment_, node, 'comment')
            self.comment = comment_
# end class DEXdecrementX


class INXincrementX(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, name=None, value=None, comment=None):
        self.name = name
        self.value = value
        self.comment = comment
    def factory(*args_, **kwargs_):
        if INXincrementX.subclass:
            return INXincrementX.subclass(*args_, **kwargs_)
        else:
            return INXincrementX(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_name(self): return self.name
    def set_name(self, name): self.name = name
    def get_value(self): return self.value
    def set_value(self, value): self.value = value
    def get_comment(self): return self.comment
    def set_comment(self, comment): self.comment = comment
    def export(self, outfile, level, namespace_='', name_='INXincrementX', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = []
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='INXincrementX')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_, name_, pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='INXincrementX'):
        pass
    def exportChildren(self, outfile, level, namespace_='', name_='INXincrementX', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.name is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sname>%s</%sname>%s' % (namespace_, self.gds_format_string(quote_xml(self.name).encode(ExternalEncoding), input_name='name'), namespace_, eol_))
        if self.value is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%svalue>%s</%svalue>%s' % (namespace_, self.gds_format_string(quote_xml(self.value).encode(ExternalEncoding), input_name='value'), namespace_, eol_))
        if self.comment is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%scomment>%s</%scomment>%s' % (namespace_, self.gds_format_string(quote_xml(self.comment).encode(ExternalEncoding), input_name='comment'), namespace_, eol_))
    def hasContent_(self):
        if (
            self.name is not None or
            self.value is not None or
            self.comment is not None
            ):
            return True
        else:
            return False
    def exportLiteral(self, outfile, level, name_='INXincrementX'):
        level += 1
        self.exportLiteralAttributes(outfile, level, [], name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        pass
    def exportLiteralChildren(self, outfile, level, name_):
        if self.name is not None:
            showIndent(outfile, level)
            outfile.write('name=%s,\n' % quote_python(self.name).encode(ExternalEncoding))
        if self.value is not None:
            showIndent(outfile, level)
            outfile.write('value=%s,\n' % quote_python(self.value).encode(ExternalEncoding))
        if self.comment is not None:
            showIndent(outfile, level)
            outfile.write('comment=%s,\n' % quote_python(self.comment).encode(ExternalEncoding))
    def build(self, node):
        self.buildAttributes(node, node.attrib, [])
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'name':
            name_ = child_.text
            name_ = re_.sub(String_cleanup_pat_, " ", name_).strip()
            name_ = self.gds_validate_string(name_, node, 'name')
            self.name = name_
        elif nodeName_ == 'value':
            value_ = child_.text
            value_ = self.gds_validate_string(value_, node, 'value')
            self.value = value_
        elif nodeName_ == 'comment':
            comment_ = child_.text
            comment_ = self.gds_validate_string(comment_, node, 'comment')
            self.comment = comment_
# end class INXincrementX


class TAYtransferAtoY(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, name=None, value=None, comment=None):
        self.name = name
        self.value = value
        self.comment = comment
    def factory(*args_, **kwargs_):
        if TAYtransferAtoY.subclass:
            return TAYtransferAtoY.subclass(*args_, **kwargs_)
        else:
            return TAYtransferAtoY(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_name(self): return self.name
    def set_name(self, name): self.name = name
    def get_value(self): return self.value
    def set_value(self, value): self.value = value
    def get_comment(self): return self.comment
    def set_comment(self, comment): self.comment = comment
    def export(self, outfile, level, namespace_='', name_='TAYtransferAtoY', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = []
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='TAYtransferAtoY')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_, name_, pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='TAYtransferAtoY'):
        pass
    def exportChildren(self, outfile, level, namespace_='', name_='TAYtransferAtoY', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.name is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sname>%s</%sname>%s' % (namespace_, self.gds_format_string(quote_xml(self.name).encode(ExternalEncoding), input_name='name'), namespace_, eol_))
        if self.value is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%svalue>%s</%svalue>%s' % (namespace_, self.gds_format_string(quote_xml(self.value).encode(ExternalEncoding), input_name='value'), namespace_, eol_))
        if self.comment is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%scomment>%s</%scomment>%s' % (namespace_, self.gds_format_string(quote_xml(self.comment).encode(ExternalEncoding), input_name='comment'), namespace_, eol_))
    def hasContent_(self):
        if (
            self.name is not None or
            self.value is not None or
            self.comment is not None
            ):
            return True
        else:
            return False
    def exportLiteral(self, outfile, level, name_='TAYtransferAtoY'):
        level += 1
        self.exportLiteralAttributes(outfile, level, [], name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        pass
    def exportLiteralChildren(self, outfile, level, name_):
        if self.name is not None:
            showIndent(outfile, level)
            outfile.write('name=%s,\n' % quote_python(self.name).encode(ExternalEncoding))
        if self.value is not None:
            showIndent(outfile, level)
            outfile.write('value=%s,\n' % quote_python(self.value).encode(ExternalEncoding))
        if self.comment is not None:
            showIndent(outfile, level)
            outfile.write('comment=%s,\n' % quote_python(self.comment).encode(ExternalEncoding))
    def build(self, node):
        self.buildAttributes(node, node.attrib, [])
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'name':
            name_ = child_.text
            name_ = re_.sub(String_cleanup_pat_, " ", name_).strip()
            name_ = self.gds_validate_string(name_, node, 'name')
            self.name = name_
        elif nodeName_ == 'value':
            value_ = child_.text
            value_ = self.gds_validate_string(value_, node, 'value')
            self.value = value_
        elif nodeName_ == 'comment':
            comment_ = child_.text
            comment_ = self.gds_validate_string(comment_, node, 'comment')
            self.comment = comment_
# end class TAYtransferAtoY


class DEYdecrementY(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, name=None, value=None, comment=None):
        self.name = name
        self.value = value
        self.comment = comment
    def factory(*args_, **kwargs_):
        if DEYdecrementY.subclass:
            return DEYdecrementY.subclass(*args_, **kwargs_)
        else:
            return DEYdecrementY(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_name(self): return self.name
    def set_name(self, name): self.name = name
    def get_value(self): return self.value
    def set_value(self, value): self.value = value
    def get_comment(self): return self.comment
    def set_comment(self, comment): self.comment = comment
    def export(self, outfile, level, namespace_='', name_='DEYdecrementY', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = []
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='DEYdecrementY')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_, name_, pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='DEYdecrementY'):
        pass
    def exportChildren(self, outfile, level, namespace_='', name_='DEYdecrementY', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.name is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sname>%s</%sname>%s' % (namespace_, self.gds_format_string(quote_xml(self.name).encode(ExternalEncoding), input_name='name'), namespace_, eol_))
        if self.value is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%svalue>%s</%svalue>%s' % (namespace_, self.gds_format_string(quote_xml(self.value).encode(ExternalEncoding), input_name='value'), namespace_, eol_))
        if self.comment is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%scomment>%s</%scomment>%s' % (namespace_, self.gds_format_string(quote_xml(self.comment).encode(ExternalEncoding), input_name='comment'), namespace_, eol_))
    def hasContent_(self):
        if (
            self.name is not None or
            self.value is not None or
            self.comment is not None
            ):
            return True
        else:
            return False
    def exportLiteral(self, outfile, level, name_='DEYdecrementY'):
        level += 1
        self.exportLiteralAttributes(outfile, level, [], name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        pass
    def exportLiteralChildren(self, outfile, level, name_):
        if self.name is not None:
            showIndent(outfile, level)
            outfile.write('name=%s,\n' % quote_python(self.name).encode(ExternalEncoding))
        if self.value is not None:
            showIndent(outfile, level)
            outfile.write('value=%s,\n' % quote_python(self.value).encode(ExternalEncoding))
        if self.comment is not None:
            showIndent(outfile, level)
            outfile.write('comment=%s,\n' % quote_python(self.comment).encode(ExternalEncoding))
    def build(self, node):
        self.buildAttributes(node, node.attrib, [])
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'name':
            name_ = child_.text
            name_ = re_.sub(String_cleanup_pat_, " ", name_).strip()
            name_ = self.gds_validate_string(name_, node, 'name')
            self.name = name_
        elif nodeName_ == 'value':
            value_ = child_.text
            value_ = self.gds_validate_string(value_, node, 'value')
            self.value = value_
        elif nodeName_ == 'comment':
            comment_ = child_.text
            comment_ = self.gds_validate_string(comment_, node, 'comment')
            self.comment = comment_
# end class DEYdecrementY


class INYincrementY(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, name=None, value=None, comment=None):
        self.name = name
        self.value = value
        self.comment = comment
    def factory(*args_, **kwargs_):
        if INYincrementY.subclass:
            return INYincrementY.subclass(*args_, **kwargs_)
        else:
            return INYincrementY(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_name(self): return self.name
    def set_name(self, name): self.name = name
    def get_value(self): return self.value
    def set_value(self, value): self.value = value
    def get_comment(self): return self.comment
    def set_comment(self, comment): self.comment = comment
    def export(self, outfile, level, namespace_='', name_='INYincrementY', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = []
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='INYincrementY')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_, name_, pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='INYincrementY'):
        pass
    def exportChildren(self, outfile, level, namespace_='', name_='INYincrementY', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.name is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sname>%s</%sname>%s' % (namespace_, self.gds_format_string(quote_xml(self.name).encode(ExternalEncoding), input_name='name'), namespace_, eol_))
        if self.value is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%svalue>%s</%svalue>%s' % (namespace_, self.gds_format_string(quote_xml(self.value).encode(ExternalEncoding), input_name='value'), namespace_, eol_))
        if self.comment is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%scomment>%s</%scomment>%s' % (namespace_, self.gds_format_string(quote_xml(self.comment).encode(ExternalEncoding), input_name='comment'), namespace_, eol_))
    def hasContent_(self):
        if (
            self.name is not None or
            self.value is not None or
            self.comment is not None
            ):
            return True
        else:
            return False
    def exportLiteral(self, outfile, level, name_='INYincrementY'):
        level += 1
        self.exportLiteralAttributes(outfile, level, [], name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        pass
    def exportLiteralChildren(self, outfile, level, name_):
        if self.name is not None:
            showIndent(outfile, level)
            outfile.write('name=%s,\n' % quote_python(self.name).encode(ExternalEncoding))
        if self.value is not None:
            showIndent(outfile, level)
            outfile.write('value=%s,\n' % quote_python(self.value).encode(ExternalEncoding))
        if self.comment is not None:
            showIndent(outfile, level)
            outfile.write('comment=%s,\n' % quote_python(self.comment).encode(ExternalEncoding))
    def build(self, node):
        self.buildAttributes(node, node.attrib, [])
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'name':
            name_ = child_.text
            name_ = re_.sub(String_cleanup_pat_, " ", name_).strip()
            name_ = self.gds_validate_string(name_, node, 'name')
            self.name = name_
        elif nodeName_ == 'value':
            value_ = child_.text
            value_ = self.gds_validate_string(value_, node, 'value')
            self.value = value_
        elif nodeName_ == 'comment':
            comment_ = child_.text
            comment_ = self.gds_validate_string(comment_, node, 'comment')
            self.comment = comment_
# end class INYincrementY


class ROLrotateLeft(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, name=None, value=None, comment=None):
        self.name = name
        if value is None:
            self.value = []
        else:
            self.value = value
        self.comment = comment
    def factory(*args_, **kwargs_):
        if ROLrotateLeft.subclass:
            return ROLrotateLeft.subclass(*args_, **kwargs_)
        else:
            return ROLrotateLeft(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_name(self): return self.name
    def set_name(self, name): self.name = name
    def get_value(self): return self.value
    def set_value(self, value): self.value = value
    def add_value(self, value): self.value.append(value)
    def insert_value(self, index, value): self.value[index] = value
    def get_comment(self): return self.comment
    def set_comment(self, comment): self.comment = comment
    def export(self, outfile, level, namespace_='', name_='ROLrotateLeft', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = []
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='ROLrotateLeft')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_, name_, pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='ROLrotateLeft'):
        pass
    def exportChildren(self, outfile, level, namespace_='', name_='ROLrotateLeft', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.name is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sname>%s</%sname>%s' % (namespace_, self.gds_format_string(quote_xml(self.name).encode(ExternalEncoding), input_name='name'), namespace_, eol_))
        for value_ in self.value:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%svalue>%s</%svalue>%s' % (namespace_, self.gds_format_string(quote_xml(value_).encode(ExternalEncoding), input_name='value'), namespace_, eol_))
        if self.comment is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%scomment>%s</%scomment>%s' % (namespace_, self.gds_format_string(quote_xml(self.comment).encode(ExternalEncoding), input_name='comment'), namespace_, eol_))
    def hasContent_(self):
        if (
            self.name is not None or
            self.value or
            self.comment is not None
            ):
            return True
        else:
            return False
    def exportLiteral(self, outfile, level, name_='ROLrotateLeft'):
        level += 1
        self.exportLiteralAttributes(outfile, level, [], name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        pass
    def exportLiteralChildren(self, outfile, level, name_):
        if self.name is not None:
            showIndent(outfile, level)
            outfile.write('name=%s,\n' % quote_python(self.name).encode(ExternalEncoding))
        showIndent(outfile, level)
        outfile.write('value=[\n')
        level += 1
        for value_ in self.value:
            showIndent(outfile, level)
            outfile.write('%s,\n' % quote_python(value_).encode(ExternalEncoding))
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
        if self.comment is not None:
            showIndent(outfile, level)
            outfile.write('comment=%s,\n' % quote_python(self.comment).encode(ExternalEncoding))
    def build(self, node):
        self.buildAttributes(node, node.attrib, [])
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'name':
            name_ = child_.text
            name_ = re_.sub(String_cleanup_pat_, " ", name_).strip()
            name_ = self.gds_validate_string(name_, node, 'name')
            self.name = name_
        elif nodeName_ == 'value':
            value_ = child_.text
            value_ = self.gds_validate_string(value_, node, 'value')
            self.value.append(value_)
        elif nodeName_ == 'comment':
            comment_ = child_.text
            comment_ = self.gds_validate_string(comment_, node, 'comment')
            self.comment = comment_
# end class ROLrotateLeft


class RORrotateRight(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, name=None, value=None, comment=None):
        self.name = name
        if value is None:
            self.value = []
        else:
            self.value = value
        self.comment = comment
    def factory(*args_, **kwargs_):
        if RORrotateRight.subclass:
            return RORrotateRight.subclass(*args_, **kwargs_)
        else:
            return RORrotateRight(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_name(self): return self.name
    def set_name(self, name): self.name = name
    def get_value(self): return self.value
    def set_value(self, value): self.value = value
    def add_value(self, value): self.value.append(value)
    def insert_value(self, index, value): self.value[index] = value
    def get_comment(self): return self.comment
    def set_comment(self, comment): self.comment = comment
    def export(self, outfile, level, namespace_='', name_='RORrotateRight', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = []
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='RORrotateRight')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_, name_, pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='RORrotateRight'):
        pass
    def exportChildren(self, outfile, level, namespace_='', name_='RORrotateRight', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.name is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sname>%s</%sname>%s' % (namespace_, self.gds_format_string(quote_xml(self.name).encode(ExternalEncoding), input_name='name'), namespace_, eol_))
        for value_ in self.value:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%svalue>%s</%svalue>%s' % (namespace_, self.gds_format_string(quote_xml(value_).encode(ExternalEncoding), input_name='value'), namespace_, eol_))
        if self.comment is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%scomment>%s</%scomment>%s' % (namespace_, self.gds_format_string(quote_xml(self.comment).encode(ExternalEncoding), input_name='comment'), namespace_, eol_))
    def hasContent_(self):
        if (
            self.name is not None or
            self.value or
            self.comment is not None
            ):
            return True
        else:
            return False
    def exportLiteral(self, outfile, level, name_='RORrotateRight'):
        level += 1
        self.exportLiteralAttributes(outfile, level, [], name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        pass
    def exportLiteralChildren(self, outfile, level, name_):
        if self.name is not None:
            showIndent(outfile, level)
            outfile.write('name=%s,\n' % quote_python(self.name).encode(ExternalEncoding))
        showIndent(outfile, level)
        outfile.write('value=[\n')
        level += 1
        for value_ in self.value:
            showIndent(outfile, level)
            outfile.write('%s,\n' % quote_python(value_).encode(ExternalEncoding))
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
        if self.comment is not None:
            showIndent(outfile, level)
            outfile.write('comment=%s,\n' % quote_python(self.comment).encode(ExternalEncoding))
    def build(self, node):
        self.buildAttributes(node, node.attrib, [])
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'name':
            name_ = child_.text
            name_ = re_.sub(String_cleanup_pat_, " ", name_).strip()
            name_ = self.gds_validate_string(name_, node, 'name')
            self.name = name_
        elif nodeName_ == 'value':
            value_ = child_.text
            value_ = self.gds_validate_string(value_, node, 'value')
            self.value.append(value_)
        elif nodeName_ == 'comment':
            comment_ = child_.text
            comment_ = self.gds_validate_string(comment_, node, 'comment')
            self.comment = comment_
# end class RORrotateRight


class RTIreturnFromInterrupt(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, name=None, value=None, comment=None):
        self.name = name
        if value is None:
            self.value = []
        else:
            self.value = value
        self.comment = comment
    def factory(*args_, **kwargs_):
        if RTIreturnFromInterrupt.subclass:
            return RTIreturnFromInterrupt.subclass(*args_, **kwargs_)
        else:
            return RTIreturnFromInterrupt(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_name(self): return self.name
    def set_name(self, name): self.name = name
    def get_value(self): return self.value
    def set_value(self, value): self.value = value
    def add_value(self, value): self.value.append(value)
    def insert_value(self, index, value): self.value[index] = value
    def get_comment(self): return self.comment
    def set_comment(self, comment): self.comment = comment
    def export(self, outfile, level, namespace_='', name_='RTIreturnFromInterrupt', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = []
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='RTIreturnFromInterrupt')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_, name_, pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='RTIreturnFromInterrupt'):
        pass
    def exportChildren(self, outfile, level, namespace_='', name_='RTIreturnFromInterrupt', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.name is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sname>%s</%sname>%s' % (namespace_, self.gds_format_string(quote_xml(self.name).encode(ExternalEncoding), input_name='name'), namespace_, eol_))
        for value_ in self.value:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%svalue>%s</%svalue>%s' % (namespace_, self.gds_format_string(quote_xml(value_).encode(ExternalEncoding), input_name='value'), namespace_, eol_))
        if self.comment is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%scomment>%s</%scomment>%s' % (namespace_, self.gds_format_string(quote_xml(self.comment).encode(ExternalEncoding), input_name='comment'), namespace_, eol_))
    def hasContent_(self):
        if (
            self.name is not None or
            self.value or
            self.comment is not None
            ):
            return True
        else:
            return False
    def exportLiteral(self, outfile, level, name_='RTIreturnFromInterrupt'):
        level += 1
        self.exportLiteralAttributes(outfile, level, [], name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        pass
    def exportLiteralChildren(self, outfile, level, name_):
        if self.name is not None:
            showIndent(outfile, level)
            outfile.write('name=%s,\n' % quote_python(self.name).encode(ExternalEncoding))
        showIndent(outfile, level)
        outfile.write('value=[\n')
        level += 1
        for value_ in self.value:
            showIndent(outfile, level)
            outfile.write('%s,\n' % quote_python(value_).encode(ExternalEncoding))
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
        if self.comment is not None:
            showIndent(outfile, level)
            outfile.write('comment=%s,\n' % quote_python(self.comment).encode(ExternalEncoding))
    def build(self, node):
        self.buildAttributes(node, node.attrib, [])
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'name':
            name_ = child_.text
            name_ = re_.sub(String_cleanup_pat_, " ", name_).strip()
            name_ = self.gds_validate_string(name_, node, 'name')
            self.name = name_
        elif nodeName_ == 'value':
            value_ = child_.text
            value_ = self.gds_validate_string(value_, node, 'value')
            self.value.append(value_)
        elif nodeName_ == 'comment':
            comment_ = child_.text
            comment_ = self.gds_validate_string(comment_, node, 'comment')
            self.comment = comment_
# end class RTIreturnFromInterrupt


class RTSreturnFromSubroutine(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, name=None, value=None, comment=None):
        self.name = name
        if value is None:
            self.value = []
        else:
            self.value = value
        self.comment = comment
    def factory(*args_, **kwargs_):
        if RTSreturnFromSubroutine.subclass:
            return RTSreturnFromSubroutine.subclass(*args_, **kwargs_)
        else:
            return RTSreturnFromSubroutine(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_name(self): return self.name
    def set_name(self, name): self.name = name
    def get_value(self): return self.value
    def set_value(self, value): self.value = value
    def add_value(self, value): self.value.append(value)
    def insert_value(self, index, value): self.value[index] = value
    def get_comment(self): return self.comment
    def set_comment(self, comment): self.comment = comment
    def export(self, outfile, level, namespace_='', name_='RTSreturnFromSubroutine', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = []
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='RTSreturnFromSubroutine')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_, name_, pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='RTSreturnFromSubroutine'):
        pass
    def exportChildren(self, outfile, level, namespace_='', name_='RTSreturnFromSubroutine', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.name is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sname>%s</%sname>%s' % (namespace_, self.gds_format_string(quote_xml(self.name).encode(ExternalEncoding), input_name='name'), namespace_, eol_))
        for value_ in self.value:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%svalue>%s</%svalue>%s' % (namespace_, self.gds_format_string(quote_xml(value_).encode(ExternalEncoding), input_name='value'), namespace_, eol_))
        if self.comment is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%scomment>%s</%scomment>%s' % (namespace_, self.gds_format_string(quote_xml(self.comment).encode(ExternalEncoding), input_name='comment'), namespace_, eol_))
    def hasContent_(self):
        if (
            self.name is not None or
            self.value or
            self.comment is not None
            ):
            return True
        else:
            return False
    def exportLiteral(self, outfile, level, name_='RTSreturnFromSubroutine'):
        level += 1
        self.exportLiteralAttributes(outfile, level, [], name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        pass
    def exportLiteralChildren(self, outfile, level, name_):
        if self.name is not None:
            showIndent(outfile, level)
            outfile.write('name=%s,\n' % quote_python(self.name).encode(ExternalEncoding))
        showIndent(outfile, level)
        outfile.write('value=[\n')
        level += 1
        for value_ in self.value:
            showIndent(outfile, level)
            outfile.write('%s,\n' % quote_python(value_).encode(ExternalEncoding))
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
        if self.comment is not None:
            showIndent(outfile, level)
            outfile.write('comment=%s,\n' % quote_python(self.comment).encode(ExternalEncoding))
    def build(self, node):
        self.buildAttributes(node, node.attrib, [])
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'name':
            name_ = child_.text
            name_ = re_.sub(String_cleanup_pat_, " ", name_).strip()
            name_ = self.gds_validate_string(name_, node, 'name')
            self.name = name_
        elif nodeName_ == 'value':
            value_ = child_.text
            value_ = self.gds_validate_string(value_, node, 'value')
            self.value.append(value_)
        elif nodeName_ == 'comment':
            comment_ = child_.text
            comment_ = self.gds_validate_string(comment_, node, 'comment')
            self.comment = comment_
# end class RTSreturnFromSubroutine


class SBCSubTractwithCarry(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, name=None, value=None, comment=None):
        self.name = name
        if value is None:
            self.value = []
        else:
            self.value = value
        self.comment = comment
    def factory(*args_, **kwargs_):
        if SBCSubTractwithCarry.subclass:
            return SBCSubTractwithCarry.subclass(*args_, **kwargs_)
        else:
            return SBCSubTractwithCarry(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_name(self): return self.name
    def set_name(self, name): self.name = name
    def get_value(self): return self.value
    def set_value(self, value): self.value = value
    def add_value(self, value): self.value.append(value)
    def insert_value(self, index, value): self.value[index] = value
    def get_comment(self): return self.comment
    def set_comment(self, comment): self.comment = comment
    def export(self, outfile, level, namespace_='', name_='SBCSubTractwithCarry', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = []
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='SBCSubTractwithCarry')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_, name_, pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='SBCSubTractwithCarry'):
        pass
    def exportChildren(self, outfile, level, namespace_='', name_='SBCSubTractwithCarry', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.name is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sname>%s</%sname>%s' % (namespace_, self.gds_format_string(quote_xml(self.name).encode(ExternalEncoding), input_name='name'), namespace_, eol_))
        for value_ in self.value:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%svalue>%s</%svalue>%s' % (namespace_, self.gds_format_string(quote_xml(value_).encode(ExternalEncoding), input_name='value'), namespace_, eol_))
        if self.comment is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%scomment>%s</%scomment>%s' % (namespace_, self.gds_format_string(quote_xml(self.comment).encode(ExternalEncoding), input_name='comment'), namespace_, eol_))
    def hasContent_(self):
        if (
            self.name is not None or
            self.value or
            self.comment is not None
            ):
            return True
        else:
            return False
    def exportLiteral(self, outfile, level, name_='SBCSubTractwithCarry'):
        level += 1
        self.exportLiteralAttributes(outfile, level, [], name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        pass
    def exportLiteralChildren(self, outfile, level, name_):
        if self.name is not None:
            showIndent(outfile, level)
            outfile.write('name=%s,\n' % quote_python(self.name).encode(ExternalEncoding))
        showIndent(outfile, level)
        outfile.write('value=[\n')
        level += 1
        for value_ in self.value:
            showIndent(outfile, level)
            outfile.write('%s,\n' % quote_python(value_).encode(ExternalEncoding))
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
        if self.comment is not None:
            showIndent(outfile, level)
            outfile.write('comment=%s,\n' % quote_python(self.comment).encode(ExternalEncoding))
    def build(self, node):
        self.buildAttributes(node, node.attrib, [])
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'name':
            name_ = child_.text
            name_ = re_.sub(String_cleanup_pat_, " ", name_).strip()
            name_ = self.gds_validate_string(name_, node, 'name')
            self.name = name_
        elif nodeName_ == 'value':
            value_ = child_.text
            value_ = self.gds_validate_string(value_, node, 'value')
            self.value.append(value_)
        elif nodeName_ == 'comment':
            comment_ = child_.text
            comment_ = self.gds_validate_string(comment_, node, 'comment')
            self.comment = comment_
# end class SBCSubTractwithCarry


class STAStoreAccumulator(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, name=None, value=None, comment=None):
        self.name = name
        if value is None:
            self.value = []
        else:
            self.value = value
        self.comment = comment
    def factory(*args_, **kwargs_):
        if STAStoreAccumulator.subclass:
            return STAStoreAccumulator.subclass(*args_, **kwargs_)
        else:
            return STAStoreAccumulator(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_name(self): return self.name
    def set_name(self, name): self.name = name
    def get_value(self): return self.value
    def set_value(self, value): self.value = value
    def add_value(self, value): self.value.append(value)
    def insert_value(self, index, value): self.value[index] = value
    def get_comment(self): return self.comment
    def set_comment(self, comment): self.comment = comment
    def export(self, outfile, level, namespace_='', name_='STAStoreAccumulator', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = []
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='STAStoreAccumulator')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_, name_, pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='STAStoreAccumulator'):
        pass
    def exportChildren(self, outfile, level, namespace_='', name_='STAStoreAccumulator', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.name is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sname>%s</%sname>%s' % (namespace_, self.gds_format_string(quote_xml(self.name).encode(ExternalEncoding), input_name='name'), namespace_, eol_))
        for value_ in self.value:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%svalue>%s</%svalue>%s' % (namespace_, self.gds_format_string(quote_xml(value_).encode(ExternalEncoding), input_name='value'), namespace_, eol_))
        if self.comment is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%scomment>%s</%scomment>%s' % (namespace_, self.gds_format_string(quote_xml(self.comment).encode(ExternalEncoding), input_name='comment'), namespace_, eol_))
    def hasContent_(self):
        if (
            self.name is not None or
            self.value or
            self.comment is not None
            ):
            return True
        else:
            return False
    def exportLiteral(self, outfile, level, name_='STAStoreAccumulator'):
        level += 1
        self.exportLiteralAttributes(outfile, level, [], name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        pass
    def exportLiteralChildren(self, outfile, level, name_):
        if self.name is not None:
            showIndent(outfile, level)
            outfile.write('name=%s,\n' % quote_python(self.name).encode(ExternalEncoding))
        showIndent(outfile, level)
        outfile.write('value=[\n')
        level += 1
        for value_ in self.value:
            showIndent(outfile, level)
            outfile.write('%s,\n' % quote_python(value_).encode(ExternalEncoding))
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
        if self.comment is not None:
            showIndent(outfile, level)
            outfile.write('comment=%s,\n' % quote_python(self.comment).encode(ExternalEncoding))
    def build(self, node):
        self.buildAttributes(node, node.attrib, [])
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'name':
            name_ = child_.text
            name_ = re_.sub(String_cleanup_pat_, " ", name_).strip()
            name_ = self.gds_validate_string(name_, node, 'name')
            self.name = name_
        elif nodeName_ == 'value':
            value_ = child_.text
            value_ = self.gds_validate_string(value_, node, 'value')
            self.value.append(value_)
        elif nodeName_ == 'comment':
            comment_ = child_.text
            comment_ = self.gds_validate_string(comment_, node, 'comment')
            self.comment = comment_
# end class STAStoreAccumulator


class TSXTransferXtoStackptr(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, name=None, value=None, comment=None):
        self.name = name
        self.value = value
        self.comment = comment
    def factory(*args_, **kwargs_):
        if TSXTransferXtoStackptr.subclass:
            return TSXTransferXtoStackptr.subclass(*args_, **kwargs_)
        else:
            return TSXTransferXtoStackptr(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_name(self): return self.name
    def set_name(self, name): self.name = name
    def get_value(self): return self.value
    def set_value(self, value): self.value = value
    def get_comment(self): return self.comment
    def set_comment(self, comment): self.comment = comment
    def export(self, outfile, level, namespace_='', name_='TSXTransferXtoStackptr', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = []
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='TSXTransferXtoStackptr')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_, name_, pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='TSXTransferXtoStackptr'):
        pass
    def exportChildren(self, outfile, level, namespace_='', name_='TSXTransferXtoStackptr', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.name is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sname>%s</%sname>%s' % (namespace_, self.gds_format_string(quote_xml(self.name).encode(ExternalEncoding), input_name='name'), namespace_, eol_))
        if self.value is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%svalue>%s</%svalue>%s' % (namespace_, self.gds_format_string(quote_xml(self.value).encode(ExternalEncoding), input_name='value'), namespace_, eol_))
        if self.comment is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%scomment>%s</%scomment>%s' % (namespace_, self.gds_format_string(quote_xml(self.comment).encode(ExternalEncoding), input_name='comment'), namespace_, eol_))
    def hasContent_(self):
        if (
            self.name is not None or
            self.value is not None or
            self.comment is not None
            ):
            return True
        else:
            return False
    def exportLiteral(self, outfile, level, name_='TSXTransferXtoStackptr'):
        level += 1
        self.exportLiteralAttributes(outfile, level, [], name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        pass
    def exportLiteralChildren(self, outfile, level, name_):
        if self.name is not None:
            showIndent(outfile, level)
            outfile.write('name=%s,\n' % quote_python(self.name).encode(ExternalEncoding))
        if self.value is not None:
            showIndent(outfile, level)
            outfile.write('value=%s,\n' % quote_python(self.value).encode(ExternalEncoding))
        if self.comment is not None:
            showIndent(outfile, level)
            outfile.write('comment=%s,\n' % quote_python(self.comment).encode(ExternalEncoding))
    def build(self, node):
        self.buildAttributes(node, node.attrib, [])
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'name':
            name_ = child_.text
            name_ = re_.sub(String_cleanup_pat_, " ", name_).strip()
            name_ = self.gds_validate_string(name_, node, 'name')
            self.name = name_
        elif nodeName_ == 'value':
            value_ = child_.text
            value_ = self.gds_validate_string(value_, node, 'value')
            self.value = value_
        elif nodeName_ == 'comment':
            comment_ = child_.text
            comment_ = self.gds_validate_string(comment_, node, 'comment')
            self.comment = comment_
# end class TSXTransferXtoStackptr


class TSXTranferStackPtrtoX(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, name=None, value=None, comment=None):
        self.name = name
        self.value = value
        self.comment = comment
    def factory(*args_, **kwargs_):
        if TSXTranferStackPtrtoX.subclass:
            return TSXTranferStackPtrtoX.subclass(*args_, **kwargs_)
        else:
            return TSXTranferStackPtrtoX(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_name(self): return self.name
    def set_name(self, name): self.name = name
    def get_value(self): return self.value
    def set_value(self, value): self.value = value
    def get_comment(self): return self.comment
    def set_comment(self, comment): self.comment = comment
    def export(self, outfile, level, namespace_='', name_='TSXTranferStackPtrtoX', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = []
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='TSXTranferStackPtrtoX')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_, name_, pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='TSXTranferStackPtrtoX'):
        pass
    def exportChildren(self, outfile, level, namespace_='', name_='TSXTranferStackPtrtoX', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.name is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sname>%s</%sname>%s' % (namespace_, self.gds_format_string(quote_xml(self.name).encode(ExternalEncoding), input_name='name'), namespace_, eol_))
        if self.value is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%svalue>%s</%svalue>%s' % (namespace_, self.gds_format_string(quote_xml(self.value).encode(ExternalEncoding), input_name='value'), namespace_, eol_))
        if self.comment is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%scomment>%s</%scomment>%s' % (namespace_, self.gds_format_string(quote_xml(self.comment).encode(ExternalEncoding), input_name='comment'), namespace_, eol_))
    def hasContent_(self):
        if (
            self.name is not None or
            self.value is not None or
            self.comment is not None
            ):
            return True
        else:
            return False
    def exportLiteral(self, outfile, level, name_='TSXTranferStackPtrtoX'):
        level += 1
        self.exportLiteralAttributes(outfile, level, [], name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        pass
    def exportLiteralChildren(self, outfile, level, name_):
        if self.name is not None:
            showIndent(outfile, level)
            outfile.write('name=%s,\n' % quote_python(self.name).encode(ExternalEncoding))
        if self.value is not None:
            showIndent(outfile, level)
            outfile.write('value=%s,\n' % quote_python(self.value).encode(ExternalEncoding))
        if self.comment is not None:
            showIndent(outfile, level)
            outfile.write('comment=%s,\n' % quote_python(self.comment).encode(ExternalEncoding))
    def build(self, node):
        self.buildAttributes(node, node.attrib, [])
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'name':
            name_ = child_.text
            name_ = re_.sub(String_cleanup_pat_, " ", name_).strip()
            name_ = self.gds_validate_string(name_, node, 'name')
            self.name = name_
        elif nodeName_ == 'value':
            value_ = child_.text
            value_ = self.gds_validate_string(value_, node, 'value')
            self.value = value_
        elif nodeName_ == 'comment':
            comment_ = child_.text
            comment_ = self.gds_validate_string(comment_, node, 'comment')
            self.comment = comment_
# end class TSXTranferStackPtrtoX


class PHAPushAccumulator(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, name=None, value=None, comment=None):
        self.name = name
        self.value = value
        self.comment = comment
    def factory(*args_, **kwargs_):
        if PHAPushAccumulator.subclass:
            return PHAPushAccumulator.subclass(*args_, **kwargs_)
        else:
            return PHAPushAccumulator(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_name(self): return self.name
    def set_name(self, name): self.name = name
    def get_value(self): return self.value
    def set_value(self, value): self.value = value
    def get_comment(self): return self.comment
    def set_comment(self, comment): self.comment = comment
    def export(self, outfile, level, namespace_='', name_='PHAPushAccumulator', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = []
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='PHAPushAccumulator')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_, name_, pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='PHAPushAccumulator'):
        pass
    def exportChildren(self, outfile, level, namespace_='', name_='PHAPushAccumulator', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.name is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sname>%s</%sname>%s' % (namespace_, self.gds_format_string(quote_xml(self.name).encode(ExternalEncoding), input_name='name'), namespace_, eol_))
        if self.value is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%svalue>%s</%svalue>%s' % (namespace_, self.gds_format_string(quote_xml(self.value).encode(ExternalEncoding), input_name='value'), namespace_, eol_))
        if self.comment is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%scomment>%s</%scomment>%s' % (namespace_, self.gds_format_string(quote_xml(self.comment).encode(ExternalEncoding), input_name='comment'), namespace_, eol_))
    def hasContent_(self):
        if (
            self.name is not None or
            self.value is not None or
            self.comment is not None
            ):
            return True
        else:
            return False
    def exportLiteral(self, outfile, level, name_='PHAPushAccumulator'):
        level += 1
        self.exportLiteralAttributes(outfile, level, [], name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        pass
    def exportLiteralChildren(self, outfile, level, name_):
        if self.name is not None:
            showIndent(outfile, level)
            outfile.write('name=%s,\n' % quote_python(self.name).encode(ExternalEncoding))
        if self.value is not None:
            showIndent(outfile, level)
            outfile.write('value=%s,\n' % quote_python(self.value).encode(ExternalEncoding))
        if self.comment is not None:
            showIndent(outfile, level)
            outfile.write('comment=%s,\n' % quote_python(self.comment).encode(ExternalEncoding))
    def build(self, node):
        self.buildAttributes(node, node.attrib, [])
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'name':
            name_ = child_.text
            name_ = re_.sub(String_cleanup_pat_, " ", name_).strip()
            name_ = self.gds_validate_string(name_, node, 'name')
            self.name = name_
        elif nodeName_ == 'value':
            value_ = child_.text
            value_ = self.gds_validate_string(value_, node, 'value')
            self.value = value_
        elif nodeName_ == 'comment':
            comment_ = child_.text
            comment_ = self.gds_validate_string(comment_, node, 'comment')
            self.comment = comment_
# end class PHAPushAccumulator


class PLApullAccumulator(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, name=None, value=None, comment=None):
        self.name = name
        self.value = value
        self.comment = comment
    def factory(*args_, **kwargs_):
        if PLApullAccumulator.subclass:
            return PLApullAccumulator.subclass(*args_, **kwargs_)
        else:
            return PLApullAccumulator(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_name(self): return self.name
    def set_name(self, name): self.name = name
    def get_value(self): return self.value
    def set_value(self, value): self.value = value
    def get_comment(self): return self.comment
    def set_comment(self, comment): self.comment = comment
    def export(self, outfile, level, namespace_='', name_='PLApullAccumulator', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = []
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='PLApullAccumulator')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_, name_, pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='PLApullAccumulator'):
        pass
    def exportChildren(self, outfile, level, namespace_='', name_='PLApullAccumulator', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.name is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sname>%s</%sname>%s' % (namespace_, self.gds_format_string(quote_xml(self.name).encode(ExternalEncoding), input_name='name'), namespace_, eol_))
        if self.value is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%svalue>%s</%svalue>%s' % (namespace_, self.gds_format_string(quote_xml(self.value).encode(ExternalEncoding), input_name='value'), namespace_, eol_))
        if self.comment is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%scomment>%s</%scomment>%s' % (namespace_, self.gds_format_string(quote_xml(self.comment).encode(ExternalEncoding), input_name='comment'), namespace_, eol_))
    def hasContent_(self):
        if (
            self.name is not None or
            self.value is not None or
            self.comment is not None
            ):
            return True
        else:
            return False
    def exportLiteral(self, outfile, level, name_='PLApullAccumulator'):
        level += 1
        self.exportLiteralAttributes(outfile, level, [], name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        pass
    def exportLiteralChildren(self, outfile, level, name_):
        if self.name is not None:
            showIndent(outfile, level)
            outfile.write('name=%s,\n' % quote_python(self.name).encode(ExternalEncoding))
        if self.value is not None:
            showIndent(outfile, level)
            outfile.write('value=%s,\n' % quote_python(self.value).encode(ExternalEncoding))
        if self.comment is not None:
            showIndent(outfile, level)
            outfile.write('comment=%s,\n' % quote_python(self.comment).encode(ExternalEncoding))
    def build(self, node):
        self.buildAttributes(node, node.attrib, [])
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'name':
            name_ = child_.text
            name_ = re_.sub(String_cleanup_pat_, " ", name_).strip()
            name_ = self.gds_validate_string(name_, node, 'name')
            self.name = name_
        elif nodeName_ == 'value':
            value_ = child_.text
            value_ = self.gds_validate_string(value_, node, 'value')
            self.value = value_
        elif nodeName_ == 'comment':
            comment_ = child_.text
            comment_ = self.gds_validate_string(comment_, node, 'comment')
            self.comment = comment_
# end class PLApullAccumulator


class PHPpushProcessorStatus(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, name=None, value=None, comment=None):
        self.name = name
        self.value = value
        self.comment = comment
    def factory(*args_, **kwargs_):
        if PHPpushProcessorStatus.subclass:
            return PHPpushProcessorStatus.subclass(*args_, **kwargs_)
        else:
            return PHPpushProcessorStatus(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_name(self): return self.name
    def set_name(self, name): self.name = name
    def get_value(self): return self.value
    def set_value(self, value): self.value = value
    def get_comment(self): return self.comment
    def set_comment(self, comment): self.comment = comment
    def export(self, outfile, level, namespace_='', name_='PHPpushProcessorStatus', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = []
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='PHPpushProcessorStatus')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_, name_, pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='PHPpushProcessorStatus'):
        pass
    def exportChildren(self, outfile, level, namespace_='', name_='PHPpushProcessorStatus', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.name is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sname>%s</%sname>%s' % (namespace_, self.gds_format_string(quote_xml(self.name).encode(ExternalEncoding), input_name='name'), namespace_, eol_))
        if self.value is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%svalue>%s</%svalue>%s' % (namespace_, self.gds_format_string(quote_xml(self.value).encode(ExternalEncoding), input_name='value'), namespace_, eol_))
        if self.comment is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%scomment>%s</%scomment>%s' % (namespace_, self.gds_format_string(quote_xml(self.comment).encode(ExternalEncoding), input_name='comment'), namespace_, eol_))
    def hasContent_(self):
        if (
            self.name is not None or
            self.value is not None or
            self.comment is not None
            ):
            return True
        else:
            return False
    def exportLiteral(self, outfile, level, name_='PHPpushProcessorStatus'):
        level += 1
        self.exportLiteralAttributes(outfile, level, [], name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        pass
    def exportLiteralChildren(self, outfile, level, name_):
        if self.name is not None:
            showIndent(outfile, level)
            outfile.write('name=%s,\n' % quote_python(self.name).encode(ExternalEncoding))
        if self.value is not None:
            showIndent(outfile, level)
            outfile.write('value=%s,\n' % quote_python(self.value).encode(ExternalEncoding))
        if self.comment is not None:
            showIndent(outfile, level)
            outfile.write('comment=%s,\n' % quote_python(self.comment).encode(ExternalEncoding))
    def build(self, node):
        self.buildAttributes(node, node.attrib, [])
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'name':
            name_ = child_.text
            name_ = re_.sub(String_cleanup_pat_, " ", name_).strip()
            name_ = self.gds_validate_string(name_, node, 'name')
            self.name = name_
        elif nodeName_ == 'value':
            value_ = child_.text
            value_ = self.gds_validate_string(value_, node, 'value')
            self.value = value_
        elif nodeName_ == 'comment':
            comment_ = child_.text
            comment_ = self.gds_validate_string(comment_, node, 'comment')
            self.comment = comment_
# end class PHPpushProcessorStatus


class PLPpullProcessorsStatus(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, name=None, value=None, comment=None):
        self.name = name
        self.value = value
        self.comment = comment
    def factory(*args_, **kwargs_):
        if PLPpullProcessorsStatus.subclass:
            return PLPpullProcessorsStatus.subclass(*args_, **kwargs_)
        else:
            return PLPpullProcessorsStatus(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_name(self): return self.name
    def set_name(self, name): self.name = name
    def get_value(self): return self.value
    def set_value(self, value): self.value = value
    def get_comment(self): return self.comment
    def set_comment(self, comment): self.comment = comment
    def export(self, outfile, level, namespace_='', name_='PLPpullProcessorsStatus', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = []
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='PLPpullProcessorsStatus')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_, name_, pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='PLPpullProcessorsStatus'):
        pass
    def exportChildren(self, outfile, level, namespace_='', name_='PLPpullProcessorsStatus', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.name is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sname>%s</%sname>%s' % (namespace_, self.gds_format_string(quote_xml(self.name).encode(ExternalEncoding), input_name='name'), namespace_, eol_))
        if self.value is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%svalue>%s</%svalue>%s' % (namespace_, self.gds_format_string(quote_xml(self.value).encode(ExternalEncoding), input_name='value'), namespace_, eol_))
        if self.comment is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%scomment>%s</%scomment>%s' % (namespace_, self.gds_format_string(quote_xml(self.comment).encode(ExternalEncoding), input_name='comment'), namespace_, eol_))
    def hasContent_(self):
        if (
            self.name is not None or
            self.value is not None or
            self.comment is not None
            ):
            return True
        else:
            return False
    def exportLiteral(self, outfile, level, name_='PLPpullProcessorsStatus'):
        level += 1
        self.exportLiteralAttributes(outfile, level, [], name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        pass
    def exportLiteralChildren(self, outfile, level, name_):
        if self.name is not None:
            showIndent(outfile, level)
            outfile.write('name=%s,\n' % quote_python(self.name).encode(ExternalEncoding))
        if self.value is not None:
            showIndent(outfile, level)
            outfile.write('value=%s,\n' % quote_python(self.value).encode(ExternalEncoding))
        if self.comment is not None:
            showIndent(outfile, level)
            outfile.write('comment=%s,\n' % quote_python(self.comment).encode(ExternalEncoding))
    def build(self, node):
        self.buildAttributes(node, node.attrib, [])
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'name':
            name_ = child_.text
            name_ = re_.sub(String_cleanup_pat_, " ", name_).strip()
            name_ = self.gds_validate_string(name_, node, 'name')
            self.name = name_
        elif nodeName_ == 'value':
            value_ = child_.text
            value_ = self.gds_validate_string(value_, node, 'value')
            self.value = value_
        elif nodeName_ == 'comment':
            comment_ = child_.text
            comment_ = self.gds_validate_string(comment_, node, 'comment')
            self.comment = comment_
# end class PLPpullProcessorsStatus


class STXstoreXReigster(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, name=None, value=None, comment=None):
        self.name = name
        if value is None:
            self.value = []
        else:
            self.value = value
        self.comment = comment
    def factory(*args_, **kwargs_):
        if STXstoreXReigster.subclass:
            return STXstoreXReigster.subclass(*args_, **kwargs_)
        else:
            return STXstoreXReigster(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_name(self): return self.name
    def set_name(self, name): self.name = name
    def get_value(self): return self.value
    def set_value(self, value): self.value = value
    def add_value(self, value): self.value.append(value)
    def insert_value(self, index, value): self.value[index] = value
    def get_comment(self): return self.comment
    def set_comment(self, comment): self.comment = comment
    def export(self, outfile, level, namespace_='', name_='STXstoreXReigster', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = []
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='STXstoreXReigster')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_, name_, pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='STXstoreXReigster'):
        pass
    def exportChildren(self, outfile, level, namespace_='', name_='STXstoreXReigster', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.name is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sname>%s</%sname>%s' % (namespace_, self.gds_format_string(quote_xml(self.name).encode(ExternalEncoding), input_name='name'), namespace_, eol_))
        for value_ in self.value:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%svalue>%s</%svalue>%s' % (namespace_, self.gds_format_string(quote_xml(value_).encode(ExternalEncoding), input_name='value'), namespace_, eol_))
        if self.comment is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%scomment>%s</%scomment>%s' % (namespace_, self.gds_format_string(quote_xml(self.comment).encode(ExternalEncoding), input_name='comment'), namespace_, eol_))
    def hasContent_(self):
        if (
            self.name is not None or
            self.value or
            self.comment is not None
            ):
            return True
        else:
            return False
    def exportLiteral(self, outfile, level, name_='STXstoreXReigster'):
        level += 1
        self.exportLiteralAttributes(outfile, level, [], name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        pass
    def exportLiteralChildren(self, outfile, level, name_):
        if self.name is not None:
            showIndent(outfile, level)
            outfile.write('name=%s,\n' % quote_python(self.name).encode(ExternalEncoding))
        showIndent(outfile, level)
        outfile.write('value=[\n')
        level += 1
        for value_ in self.value:
            showIndent(outfile, level)
            outfile.write('%s,\n' % quote_python(value_).encode(ExternalEncoding))
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
        if self.comment is not None:
            showIndent(outfile, level)
            outfile.write('comment=%s,\n' % quote_python(self.comment).encode(ExternalEncoding))
    def build(self, node):
        self.buildAttributes(node, node.attrib, [])
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'name':
            name_ = child_.text
            name_ = re_.sub(String_cleanup_pat_, " ", name_).strip()
            name_ = self.gds_validate_string(name_, node, 'name')
            self.name = name_
        elif nodeName_ == 'value':
            value_ = child_.text
            value_ = self.gds_validate_string(value_, node, 'value')
            self.value.append(value_)
        elif nodeName_ == 'comment':
            comment_ = child_.text
            comment_ = self.gds_validate_string(comment_, node, 'comment')
            self.comment = comment_
# end class STXstoreXReigster


class STYstoreYRegister(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, name=None, value=None, comment=None):
        self.name = name
        if value is None:
            self.value = []
        else:
            self.value = value
        self.comment = comment
    def factory(*args_, **kwargs_):
        if STYstoreYRegister.subclass:
            return STYstoreYRegister.subclass(*args_, **kwargs_)
        else:
            return STYstoreYRegister(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_name(self): return self.name
    def set_name(self, name): self.name = name
    def get_value(self): return self.value
    def set_value(self, value): self.value = value
    def add_value(self, value): self.value.append(value)
    def insert_value(self, index, value): self.value[index] = value
    def get_comment(self): return self.comment
    def set_comment(self, comment): self.comment = comment
    def export(self, outfile, level, namespace_='', name_='STYstoreYRegister', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = []
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='STYstoreYRegister')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_, name_, pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='STYstoreYRegister'):
        pass
    def exportChildren(self, outfile, level, namespace_='', name_='STYstoreYRegister', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.name is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sname>%s</%sname>%s' % (namespace_, self.gds_format_string(quote_xml(self.name).encode(ExternalEncoding), input_name='name'), namespace_, eol_))
        for value_ in self.value:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%svalue>%s</%svalue>%s' % (namespace_, self.gds_format_string(quote_xml(value_).encode(ExternalEncoding), input_name='value'), namespace_, eol_))
        if self.comment is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%scomment>%s</%scomment>%s' % (namespace_, self.gds_format_string(quote_xml(self.comment).encode(ExternalEncoding), input_name='comment'), namespace_, eol_))
    def hasContent_(self):
        if (
            self.name is not None or
            self.value or
            self.comment is not None
            ):
            return True
        else:
            return False
    def exportLiteral(self, outfile, level, name_='STYstoreYRegister'):
        level += 1
        self.exportLiteralAttributes(outfile, level, [], name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        pass
    def exportLiteralChildren(self, outfile, level, name_):
        if self.name is not None:
            showIndent(outfile, level)
            outfile.write('name=%s,\n' % quote_python(self.name).encode(ExternalEncoding))
        showIndent(outfile, level)
        outfile.write('value=[\n')
        level += 1
        for value_ in self.value:
            showIndent(outfile, level)
            outfile.write('%s,\n' % quote_python(value_).encode(ExternalEncoding))
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
        if self.comment is not None:
            showIndent(outfile, level)
            outfile.write('comment=%s,\n' % quote_python(self.comment).encode(ExternalEncoding))
    def build(self, node):
        self.buildAttributes(node, node.attrib, [])
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'name':
            name_ = child_.text
            name_ = re_.sub(String_cleanup_pat_, " ", name_).strip()
            name_ = self.gds_validate_string(name_, node, 'name')
            self.name = name_
        elif nodeName_ == 'value':
            value_ = child_.text
            value_ = self.gds_validate_string(value_, node, 'value')
            self.value.append(value_)
        elif nodeName_ == 'comment':
            comment_ = child_.text
            comment_ = self.gds_validate_string(comment_, node, 'comment')
            self.comment = comment_
# end class STYstoreYRegister


class lineGroup(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, line=None, multiLineComment=None):
        if line is None:
            self.line = []
        else:
            self.line = line
        if multiLineComment is None:
            self.multiLineComment = []
        else:
            self.multiLineComment = multiLineComment
    def factory(*args_, **kwargs_):
        if lineGroup.subclass:
            return lineGroup.subclass(*args_, **kwargs_)
        else:
            return lineGroup(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_line(self): return self.line
    def set_line(self, line): self.line = line
    def add_line(self, value): self.line.append(value)
    def insert_line(self, index, value): self.line[index] = value
    def get_multiLineComment(self): return self.multiLineComment
    def set_multiLineComment(self, multiLineComment): self.multiLineComment = multiLineComment
    def add_multiLineComment(self, value): self.multiLineComment.append(value)
    def insert_multiLineComment(self, index, value): self.multiLineComment[index] = value
    def export(self, outfile, level, namespace_='', name_='lineGroup', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = []
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='lineGroup')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_, name_, pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='lineGroup'):
        pass
    def exportChildren(self, outfile, level, namespace_='', name_='lineGroup', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        for line_ in self.line:
            line_.export(outfile, level, namespace_, name_='line', pretty_print=pretty_print)
        for multiLineComment_ in self.multiLineComment:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%smultiLineComment>%s</%smultiLineComment>%s' % (namespace_, self.gds_format_string(quote_xml(multiLineComment_).encode(ExternalEncoding), input_name='multiLineComment'), namespace_, eol_))
    def hasContent_(self):
        if (
            self.line or
            self.multiLineComment
            ):
            return True
        else:
            return False
    def exportLiteral(self, outfile, level, name_='lineGroup'):
        level += 1
        self.exportLiteralAttributes(outfile, level, [], name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        pass
    def exportLiteralChildren(self, outfile, level, name_):
        showIndent(outfile, level)
        outfile.write('line=[\n')
        level += 1
        for line_ in self.line:
            showIndent(outfile, level)
            outfile.write('model_.line(\n')
            line_.exportLiteral(outfile, level)
            showIndent(outfile, level)
            outfile.write('),\n')
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
        showIndent(outfile, level)
        outfile.write('multiLineComment=[\n')
        level += 1
        for multiLineComment_ in self.multiLineComment:
            showIndent(outfile, level)
            outfile.write('%s,\n' % quote_python(multiLineComment_).encode(ExternalEncoding))
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
    def build(self, node):
        self.buildAttributes(node, node.attrib, [])
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'line':
            obj_ = line.factory()
            obj_.build(child_)
            self.line.append(obj_)
        elif nodeName_ == 'multiLineComment':
            multiLineComment_ = child_.text
            multiLineComment_ = self.gds_validate_string(multiLineComment_, node, 'multiLineComment')
            self.multiLineComment.append(multiLineComment_)
# end class lineGroup


class line(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, mnemonic=None, label=None):
        if mnemonic is None:
            self.mnemonic = []
        else:
            self.mnemonic = mnemonic
        if label is None:
            self.label = []
        else:
            self.label = label
    def factory(*args_, **kwargs_):
        if line.subclass:
            return line.subclass(*args_, **kwargs_)
        else:
            return line(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_mnemonic(self): return self.mnemonic
    def set_mnemonic(self, mnemonic): self.mnemonic = mnemonic
    def add_mnemonic(self, value): self.mnemonic.append(value)
    def insert_mnemonic(self, index, value): self.mnemonic[index] = value
    def get_label(self): return self.label
    def set_label(self, label): self.label = label
    def add_label(self, value): self.label.append(value)
    def insert_label(self, index, value): self.label[index] = value
    def export(self, outfile, level, namespace_='', name_='line', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = []
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='line')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_, name_, pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='line'):
        pass
    def exportChildren(self, outfile, level, namespace_='', name_='line', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        for mnemonic_ in self.mnemonic:
            mnemonic_.export(outfile, level, namespace_, name_='mnemonic', pretty_print=pretty_print)
        for label_ in self.label:
            label_.export(outfile, level, namespace_, name_='label', pretty_print=pretty_print)
    def hasContent_(self):
        if (
            self.mnemonic or
            self.label
            ):
            return True
        else:
            return False
    def exportLiteral(self, outfile, level, name_='line'):
        level += 1
        self.exportLiteralAttributes(outfile, level, [], name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        pass
    def exportLiteralChildren(self, outfile, level, name_):
        showIndent(outfile, level)
        outfile.write('mnemonic=[\n')
        level += 1
        for mnemonic_ in self.mnemonic:
            showIndent(outfile, level)
            outfile.write('model_.mnemonic(\n')
            mnemonic_.exportLiteral(outfile, level)
            showIndent(outfile, level)
            outfile.write('),\n')
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
        showIndent(outfile, level)
        outfile.write('label=[\n')
        level += 1
        for label_ in self.label:
            showIndent(outfile, level)
            outfile.write('model_.label(\n')
            label_.exportLiteral(outfile, level)
            showIndent(outfile, level)
            outfile.write('),\n')
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
    def build(self, node):
        self.buildAttributes(node, node.attrib, [])
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'mnemonic':
            obj_ = mnemonic.factory()
            obj_.build(child_)
            self.mnemonic.append(obj_)
        elif nodeName_ == 'label':
            obj_ = label.factory()
            obj_.build(child_)
            self.label.append(obj_)
# end class line


class annotation(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, emph=None, term=None, cited=None, ital=None, bold=None, valueOf_=None, mixedclass_=None, content_=None):
        if emph is None:
            self.emph = []
        else:
            self.emph = emph
        if term is None:
            self.term = []
        else:
            self.term = term
        if cited is None:
            self.cited = []
        else:
            self.cited = cited
        if ital is None:
            self.ital = []
        else:
            self.ital = ital
        if bold is None:
            self.bold = []
        else:
            self.bold = bold
        self.valueOf_ = valueOf_
        if mixedclass_ is None:
            self.mixedclass_ = MixedContainer
        else:
            self.mixedclass_ = mixedclass_
        if content_ is None:
            self.content_ = []
        else:
            self.content_ = content_
        self.valueOf_ = valueOf_
    def factory(*args_, **kwargs_):
        if annotation.subclass:
            return annotation.subclass(*args_, **kwargs_)
        else:
            return annotation(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_emph(self): return self.emph
    def set_emph(self, emph): self.emph = emph
    def add_emph(self, value): self.emph.append(value)
    def insert_emph(self, index, value): self.emph[index] = value
    def get_term(self): return self.term
    def set_term(self, term): self.term = term
    def add_term(self, value): self.term.append(value)
    def insert_term(self, index, value): self.term[index] = value
    def get_cited(self): return self.cited
    def set_cited(self, cited): self.cited = cited
    def add_cited(self, value): self.cited.append(value)
    def insert_cited(self, index, value): self.cited[index] = value
    def get_ital(self): return self.ital
    def set_ital(self, ital): self.ital = ital
    def add_ital(self, value): self.ital.append(value)
    def insert_ital(self, index, value): self.ital[index] = value
    def get_bold(self): return self.bold
    def set_bold(self, bold): self.bold = bold
    def add_bold(self, value): self.bold.append(value)
    def insert_bold(self, index, value): self.bold[index] = value
    def get_valueOf_(self): return self.valueOf_
    def set_valueOf_(self, valueOf_): self.valueOf_ = valueOf_
    def export(self, outfile, level, namespace_='', name_='annotation', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = []
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='annotation')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_, name_, pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='annotation'):
        pass
    def exportChildren(self, outfile, level, namespace_='', name_='annotation', fromsubclass_=False, pretty_print=True):
        if not fromsubclass_:
            for item_ in self.content_:
                item_.export(outfile, level, item_.name, namespace_, pretty_print=pretty_print)
    def hasContent_(self):
        if (
            self.emph or
            self.term or
            self.cited or
            self.ital or
            self.bold or
            self.valueOf_
            ):
            return True
        else:
            return False
    def exportLiteral(self, outfile, level, name_='annotation'):
        level += 1
        self.exportLiteralAttributes(outfile, level, [], name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
        showIndent(outfile, level)
        outfile.write('valueOf_ = """%s""",\n' % (self.valueOf_,))
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        pass
    def exportLiteralChildren(self, outfile, level, name_):
        showIndent(outfile, level)
        outfile.write('content_ = [\n')
        for item_ in self.content_:
            item_.exportLiteral(outfile, level, name_)
        showIndent(outfile, level)
        outfile.write('],\n')
        showIndent(outfile, level)
        outfile.write('content_ = [\n')
        for item_ in self.content_:
            item_.exportLiteral(outfile, level, name_)
        showIndent(outfile, level)
        outfile.write('],\n')
        showIndent(outfile, level)
        outfile.write('content_ = [\n')
        for item_ in self.content_:
            item_.exportLiteral(outfile, level, name_)
        showIndent(outfile, level)
        outfile.write('],\n')
        showIndent(outfile, level)
        outfile.write('content_ = [\n')
        for item_ in self.content_:
            item_.exportLiteral(outfile, level, name_)
        showIndent(outfile, level)
        outfile.write('],\n')
        showIndent(outfile, level)
        outfile.write('content_ = [\n')
        for item_ in self.content_:
            item_.exportLiteral(outfile, level, name_)
        showIndent(outfile, level)
        outfile.write('],\n')
        pass
    def build(self, node):
        self.buildAttributes(node, node.attrib, [])
        self.valueOf_ = get_all_text_(node)
        if node.text is not None:
            obj_ = self.mixedclass_(MixedContainer.CategoryText,
                MixedContainer.TypeNone, '', node.text)
            self.content_.append(obj_)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'emph' and child_.text is not None:
            valuestr_ = child_.text
            obj_ = self.mixedclass_(MixedContainer.CategorySimple,
                MixedContainer.TypeString, 'emph', valuestr_)
            self.content_.append(obj_)
        elif nodeName_ == 'term' and child_.text is not None:
            valuestr_ = child_.text
            obj_ = self.mixedclass_(MixedContainer.CategorySimple,
                MixedContainer.TypeString, 'term', valuestr_)
            self.content_.append(obj_)
        elif nodeName_ == 'cited' and child_.text is not None:
            valuestr_ = child_.text
            obj_ = self.mixedclass_(MixedContainer.CategorySimple,
                MixedContainer.TypeString, 'cited', valuestr_)
            self.content_.append(obj_)
        elif nodeName_ == 'ital' and child_.text is not None:
            valuestr_ = child_.text
            obj_ = self.mixedclass_(MixedContainer.CategorySimple,
                MixedContainer.TypeString, 'ital', valuestr_)
            self.content_.append(obj_)
        elif nodeName_ == 'bold' and child_.text is not None:
            valuestr_ = child_.text
            obj_ = self.mixedclass_(MixedContainer.CategorySimple,
                MixedContainer.TypeString, 'bold', valuestr_)
            self.content_.append(obj_)
        if not fromsubclass_ and child_.tail is not None:
            obj_ = self.mixedclass_(MixedContainer.CategoryText,
                MixedContainer.TypeNone, '', child_.tail)
            self.content_.append(obj_)
# end class annotation


USAGE_TEXT = """
Usage: python <Parser>.py [ -s ] <in_xml_file>
"""

def usage():
    print USAGE_TEXT
    sys.exit(1)


def get_root_tag(node):
    tag = Tag_pattern_.match(node.tag).groups()[-1]
    rootClass = globals().get(tag)
    return tag, rootClass


def parse(inFileName):
    doc = parsexml_(inFileName)
    rootNode = doc.getroot()
    rootTag, rootClass = get_root_tag(rootNode)
    if rootClass is None:
        rootTag = 'sixfivezerotwo'
        rootClass = sixfivezerotwo
    rootObj = rootClass.factory()
    rootObj.build(rootNode)
    # Enable Python to collect the space used by the DOM.
    doc = None
    sys.stdout.write('<?xml version="1.0" ?>\n')
    rootObj.export(sys.stdout, 0, name_=rootTag,
        namespacedef_='',
        pretty_print=True)
    return rootObj


def parseString(inString):
    from StringIO import StringIO
    doc = parsexml_(StringIO(inString))
    rootNode = doc.getroot()
    rootTag, rootClass = get_root_tag(rootNode)
    if rootClass is None:
        rootTag = 'sixfivezerotwo'
        rootClass = sixfivezerotwo
    rootObj = rootClass.factory()
    rootObj.build(rootNode)
    # Enable Python to collect the space used by the DOM.
    doc = None
    sys.stdout.write('<?xml version="1.0" ?>\n')
    rootObj.export(sys.stdout, 0, name_="sixfivezerotwo",
        namespacedef_='')
    return rootObj


def parseLiteral(inFileName):
    doc = parsexml_(inFileName)
    rootNode = doc.getroot()
    rootTag, rootClass = get_root_tag(rootNode)
    if rootClass is None:
        rootTag = 'sixfivezerotwo'
        rootClass = sixfivezerotwo
    rootObj = rootClass.factory()
    rootObj.build(rootNode)
    # Enable Python to collect the space used by the DOM.
    doc = None
    sys.stdout.write('#from 6502 import *\n\n')
    sys.stdout.write('import 6502 as model_\n\n')
    sys.stdout.write('rootObj = model_.rootTag(\n')
    rootObj.exportLiteral(sys.stdout, 0, name_=rootTag)
    sys.stdout.write(')\n')
    return rootObj


def main():
    args = sys.argv[1:]
    if len(args) == 1:
        parse(args[0])
    else:
        usage()


if __name__ == '__main__':
    #import pdb; pdb.set_trace()
    main()


__all__ = [
    "ADCaddWithCarry",
    "ANDbitwiseAndWithAccumulator",
    "ASLartihmeticShiftLeft",
    "BCCbranchonCarryClear",
    "BCSbranchonCarrySet",
    "BEQbranchonEqual",
    "BITtestBits",
    "BMIbranchonMinus",
    "BNEbranchonNotequal",
    "BPLsetCarry",
    "BRKbreak",
    "BVCbranchonOverflowClear",
    "BVSbranchonOverflowSet",
    "CLClearCarry",
    "CLDclearDecimal",
    "CLIclearInterrupt",
    "CLVclearOverflow",
    "CMPcompareAccumulator",
    "CPXcompareXRegister",
    "CPYcompareYRegister",
    "DECdecrementMemory",
    "DEXdecrementX",
    "DEYdecrementY",
    "EORbitWiseExclusiveOr",
    "INCincrementMemory",
    "INXincrementX",
    "INYincrementY",
    "JMPjump",
    "JSRjumpToSubRoutine",
    "LDAloadAccumulator",
    "LDXloadXRegister",
    "LDYloadYRegister",
    "LSRlogicalShiftRight",
    "NOPnoOperation",
    "ORAbitwiseOrWithAccumulator",
    "PHAPushAccumulator",
    "PHPpushProcessorStatus",
    "PLApullAccumulator",
    "PLPpullProcessorsStatus",
    "ROLrotateLeft",
    "RORrotateRight",
    "RTIreturnFromInterrupt",
    "RTSreturnFromSubroutine",
    "SBCSubTractwithCarry",
    "SECsetCarry",
    "SEDsetDecimal",
    "SEIsetCarry",
    "SEIsetInterrupt",
    "STAStoreAccumulator",
    "STXstoreXReigster",
    "STYstoreYRegister",
    "TAXTtansferAtoX",
    "TAYtransferAtoY",
    "TSXTranferStackPtrtoX",
    "TSXTransferXtoStackptr",
    "TXAtransferXtoA",
    "annotation",
    "label",
    "line",
    "lineGroup",
    "mnemonic",
    "name",
    "sixfivezerotwo"
    ]
